---
title: plānošanas programmas veiktspējas uzlabošana
description: Šajā tēmā ir sniegta informācija par plānošanas programmu un to, kā uzlabot veiktspēju.
author: ChristianRytt
ms.date: 09/03/2020
ms.topic: article
ms.prod: ''
ms.technology: ''
ms.search.form: ''
audience: Application User
ms.reviewer: kamaybac
ms.custom: 19311
ms.assetid: 5ffb1486-2e08-4cdc-bd34-b47ae795ef0f
ms.search.region: Global
ms.search.industry: ''
ms.author: kamaybac
ms.search.validFrom: 2020-09-03
ms.dyn365.ops.version: ''
ms.openlocfilehash: d1378ae652ea70cba941316f4667052dcb05f717
ms.sourcegitcommit: 0e8db169c3f90bd750826af76709ef5d621fd377
ms.translationtype: HT
ms.contentlocale: lv-LV
ms.lasthandoff: 04/01/2021
ms.locfileid: "5812912"
---
# <a name="improve-scheduling-engine-performance"></a><span data-ttu-id="21bb8-103">plānošanas programmas veiktspējas uzlabošana</span><span class="sxs-lookup"><span data-stu-id="21bb8-103">Improve scheduling engine performance</span></span>

[!include [banner](../includes/banner.md)]

<span data-ttu-id="21bb8-104">Resursu plānošanas programmu izmanto, plānojot maršrutus plānotajiem un nodotajiem ražošanas pasūtījumiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-104">The resource scheduling engine is used when scheduling routes for planned and released production orders.</span></span> <span data-ttu-id="21bb8-105">Programma sākotnēji tika izlaista kā daļa no Dynamics AX 2012, un kopš tās izlaišanas programmai bijušo vairāki uzlabojumi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-105">The engine was originally released as part of Dynamics AX 2012 and has gone through several improvements since its release.</span></span>

<span data-ttu-id="21bb8-106">[Darbu veikalu plānošanas problēma](https://en.wikipedia.org/wiki/Job_shop_scheduling) ir ārkārtīgi sarežģīta, kombinēta problēma, kur risināšanas laiks eksponenciāli palielinās līdz ar lēmumu variantu skaitu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-106">The [job shop scheduling problem](https://en.wikipedia.org/wiki/Job_shop_scheduling) is an extremely complex combinatorial problem where solution time grows exponentially with the number of decision variables.</span></span> <span data-ttu-id="21bb8-107">Nereti klienti iestata ražošanas maršrutus un saistītos datus veidā, kas izraisa plānošanas problēmu, ko nevar atrisināt saprātīgā laikā, pat lietojot vismodernāko aparatūru.</span><span class="sxs-lookup"><span data-stu-id="21bb8-107">Oftentimes, customers set up production routes and related data in a way that results in a scheduling problem that can't be solved in reasonable time even on the most modern hardware.</span></span> <span data-ttu-id="21bb8-108">Šī tēma palīdzēs jums izprast plānošanas programmu un to, kā noteiktiem iestatījumiem var būt ietekme uz veiktspēju.</span><span class="sxs-lookup"><span data-stu-id="21bb8-108">This topic will help you understand the scheduling engine and how a specific setup can have influence on the performance.</span></span>

<span data-ttu-id="21bb8-109">Lai uzlabotu plānošanas veiktspēju, vispārējās vadlīnijas iesaka samazināt problēmas sarežģītību, kas programmai ir jārisina.</span><span class="sxs-lookup"><span data-stu-id="21bb8-109">When it comes to improving the performance of the scheduling, general guidelines recommend reducing the complexity of the problem the engine needs to solve.</span></span> <span data-ttu-id="21bb8-110">Daži no galvenajiem faktoriem, kas var ietekmēt veiktspēju, ir šādi:</span><span class="sxs-lookup"><span data-stu-id="21bb8-110">Some of the main factors that can affect performance include:</span></span>

- <span data-ttu-id="21bb8-111">Maršruti ar daudzām operācijām</span><span class="sxs-lookup"><span data-stu-id="21bb8-111">Routes with many operations</span></span>
- <span data-ttu-id="21bb8-112">Maršruti ar vienlaicīgām operācijām</span><span class="sxs-lookup"><span data-stu-id="21bb8-112">Routes with parallel operations</span></span>
- <span data-ttu-id="21bb8-113">Darbības ar resursu daudzumu, kas lielāks par vienu</span><span class="sxs-lookup"><span data-stu-id="21bb8-113">Operations with quantity of resources higher than one</span></span>
- <span data-ttu-id="21bb8-114">Operācijas ar daudziem piemērojamiem resursiem</span><span class="sxs-lookup"><span data-stu-id="21bb8-114">Operations with many applicable resources</span></span>
- <span data-ttu-id="21bb8-115">Fiksēto saišu izmantošana</span><span class="sxs-lookup"><span data-stu-id="21bb8-115">Use of hard links</span></span>
- <span data-ttu-id="21bb8-116">Ierobežotas noslodzes izmantošana</span><span class="sxs-lookup"><span data-stu-id="21bb8-116">Use of finite capacity</span></span>
- <span data-ttu-id="21bb8-117">Dažādu izmantoto kalendāru skaits</span><span class="sxs-lookup"><span data-stu-id="21bb8-117">The number of different calendars used</span></span>
- <span data-ttu-id="21bb8-118">Darba laika slotu skaits kalendārās dienas ietvaros</span><span class="sxs-lookup"><span data-stu-id="21bb8-118">The number of working time slots per day in the calendar</span></span>
- <span data-ttu-id="21bb8-119">Maršruta kopējais ilgums</span><span class="sxs-lookup"><span data-stu-id="21bb8-119">Total duration of the route</span></span>
- <span data-ttu-id="21bb8-120">Vairāku plānošanas dzinēju vienlaicīga palaišana</span><span class="sxs-lookup"><span data-stu-id="21bb8-120">Running multiple scheduling engines in parallel</span></span>

## <a name="overview-of-basic-scheduling-flow"></a><span data-ttu-id="21bb8-121">Pamata plānošanas plūsmas pārskats</span><span class="sxs-lookup"><span data-stu-id="21bb8-121">Overview of basic scheduling flow</span></span>

<span data-ttu-id="21bb8-122">Lai saprastu, kā attiecīgie iestatījumi var ietekmēt veiktspēju, ir svarīgi zināmā mērā saprast, kā process plūst gan programmā, gan X++ kodā, kas to ietver.</span><span class="sxs-lookup"><span data-stu-id="21bb8-122">To understand how a given setup can affect performance, it is important to understand something about how the process flows, both inside the engine and in the X++ code that surrounds it.</span></span>

<span data-ttu-id="21bb8-123">Pasūtījuma plānošanas pamata process sastāv no trim galvenajām darbībām:</span><span class="sxs-lookup"><span data-stu-id="21bb8-123">The basic process of scheduling an order consists of three main steps:</span></span>

- <span data-ttu-id="21bb8-124">**Datu ielāde** — Šeit X++ datu modeļi tiek pārveidoti par programmas iekšējo datu modeli darbu un ierobežojumu formā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-124">**Loading data** – Here, the X++ data models are transformed into the engine's internal data model in the form of jobs and constraints.</span></span>
- <span data-ttu-id="21bb8-125">**Plānošana** — šis ir galvenais avots plānošanai, kas apstrādā doto modeli un ierobežojumus un ģenerē rezultātu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-125">**Scheduling** – This is the main source for scheduling that processes the given model and constraints, and generates a result.</span></span> <span data-ttu-id="21bb8-126">Šī procesa laikā programma pēc nepieciešamības pieprasīs darba laika informāciju un esošās noslodzes rezervācijas no X++.</span><span class="sxs-lookup"><span data-stu-id="21bb8-126">During this process, the engine will request working time information and existing capacity reservations from X++ as needed.</span></span>
- <span data-ttu-id="21bb8-127">**Saglabāt datus** — programmas rezultāts darba noslodzes rezervācijas slotu formā tiek apstrādāts, izmantojot X++ kodu, lai saglabātu noslodzes rezervācijas un atjauninātu darbu/operāciju/pasūtījumu sākuma un beigu laikus.</span><span class="sxs-lookup"><span data-stu-id="21bb8-127">**Save data** – The engine result in the form of job capacity reservation slots is processed by X++ code to save capacity reservations and update the start and end times of the jobs/operation/order.</span></span>

## <a name="load-data-into-the-engine"></a><span data-ttu-id="21bb8-128">Datu ielāde programmā</span><span class="sxs-lookup"><span data-stu-id="21bb8-128">Load data into the engine</span></span>

<span data-ttu-id="21bb8-129">Plānošanas programmai ir abstraktāks datu modelis nekā Supply Chain Management datu bāzei, jo tā ir izveidota kā vispārīgā programma, kas var apstrādāt dažādus datu avotus.</span><span class="sxs-lookup"><span data-stu-id="21bb8-129">The scheduling engine has a more abstract data model than the Supply Chain Management database because it has been built as a generic engine that can handle different sources of data.</span></span> <span data-ttu-id="21bb8-130">Maršruta, sekundāro operāciju un izpildes laika jēdzieni ir „jātulko” vispārīgajā darba un ierobežojumu modelī, ko parāda programma.</span><span class="sxs-lookup"><span data-stu-id="21bb8-130">The concepts of route, secondary operations, and run time need to be "translated" into the generic job and constraint model that the engine exposes.</span></span> <span data-ttu-id="21bb8-131">Modeļa izveides loģikā ir ievērojama daļā biznesa loģikas, un tā atšķiras atkarībā no avota datiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-131">The logic for building the model has a significant amount of business logic to it and is different depending on the source data.</span></span> <span data-ttu-id="21bb8-132">Atbildīgā X++ klase ir `WrkCtrScheduler`, un tai ir atvasinātās klases plānotajiem ražošanas pasūtījumiem, nodotajiem ražošanas pasūtījumiem un projekta prognozēm.</span><span class="sxs-lookup"><span data-stu-id="21bb8-132">The responsible X++ class is `WrkCtrScheduler` and it has derived classes for planned production orders, released production orders, and project forecasts.</span></span>

<span data-ttu-id="21bb8-133">Piemēram, apsveriet maršrutu, kas parādīts tālāk redzamajā tabulā un attēlā, kas izskatās samērā vienkāršs.</span><span class="sxs-lookup"><span data-stu-id="21bb8-133">As an example, consider a route shown in the following table and image, which seems relatively simple.</span></span>

| <span data-ttu-id="21bb8-134">Oper.</span><span class="sxs-lookup"><span data-stu-id="21bb8-134">Oper.</span></span> <span data-ttu-id="21bb8-135">Nr.p.k.</span><span class="sxs-lookup"><span data-stu-id="21bb8-135">No.</span></span> | <span data-ttu-id="21bb8-136">Prioritāte</span><span class="sxs-lookup"><span data-stu-id="21bb8-136">Priority</span></span> | <span data-ttu-id="21bb8-137">Uzstādīšanas laiks</span><span class="sxs-lookup"><span data-stu-id="21bb8-137">Setup time</span></span> | <span data-ttu-id="21bb8-138">Izpildes laiks</span><span class="sxs-lookup"><span data-stu-id="21bb8-138">Run time</span></span> | <span data-ttu-id="21bb8-139">Gaidīšanas laiks pēc</span><span class="sxs-lookup"><span data-stu-id="21bb8-139">Queue time after</span></span> | <span data-ttu-id="21bb8-140">Resursu daudzums</span><span class="sxs-lookup"><span data-stu-id="21bb8-140">Quantity of resources</span></span> | <span data-ttu-id="21bb8-141">Nākamā</span><span class="sxs-lookup"><span data-stu-id="21bb8-141">Next</span></span> |
| --- | --- | --- | --- | --- | --- | --- |
| <span data-ttu-id="21bb8-142">10.</span><span class="sxs-lookup"><span data-stu-id="21bb8-142">10</span></span> | <span data-ttu-id="21bb8-143">Primārais</span><span class="sxs-lookup"><span data-stu-id="21bb8-143">Primary</span></span> | <span data-ttu-id="21bb8-144">1.00</span><span class="sxs-lookup"><span data-stu-id="21bb8-144">1.00</span></span> | <span data-ttu-id="21bb8-145">2.00</span><span class="sxs-lookup"><span data-stu-id="21bb8-145">2.00</span></span> | | <span data-ttu-id="21bb8-146">1</span><span class="sxs-lookup"><span data-stu-id="21bb8-146">1</span></span> | <span data-ttu-id="21bb8-147">20</span><span class="sxs-lookup"><span data-stu-id="21bb8-147">20</span></span> |
| <span data-ttu-id="21bb8-148">10.</span><span class="sxs-lookup"><span data-stu-id="21bb8-148">10</span></span> | <span data-ttu-id="21bb8-149">Sekundārs&nbsp;1</span><span class="sxs-lookup"><span data-stu-id="21bb8-149">Secondary&nbsp;1</span></span> | | | | <span data-ttu-id="21bb8-150">1</span><span class="sxs-lookup"><span data-stu-id="21bb8-150">1</span></span> | <span data-ttu-id="21bb8-151">20</span><span class="sxs-lookup"><span data-stu-id="21bb8-151">20</span></span> |
| <span data-ttu-id="21bb8-152">20</span><span class="sxs-lookup"><span data-stu-id="21bb8-152">20</span></span> | <span data-ttu-id="21bb8-153">Primārais</span><span class="sxs-lookup"><span data-stu-id="21bb8-153">Primary</span></span> | | <span data-ttu-id="21bb8-154">3.00</span><span class="sxs-lookup"><span data-stu-id="21bb8-154">3.00</span></span> | <span data-ttu-id="21bb8-155">1.00</span><span class="sxs-lookup"><span data-stu-id="21bb8-155">1.00</span></span> | <span data-ttu-id="21bb8-156">3</span><span class="sxs-lookup"><span data-stu-id="21bb8-156">3</span></span> | <span data-ttu-id="21bb8-157">0</span><span class="sxs-lookup"><span data-stu-id="21bb8-157">0</span></span> |

<span data-ttu-id="21bb8-158">![Maršruta parauga diagramma](media/scheduling-engine-route.png "Maršruta parauga diagramma")</span><span class="sxs-lookup"><span data-stu-id="21bb8-158">![Example rout diagram](media/scheduling-engine-route.png "Example rout diagram")</span></span>

<span data-ttu-id="21bb8-159">Sūtot to uz programmu, tā tiek sadalīta astoņos darbos, kā parādīts tālāk redzamajā ilustrācijā (atlasiet attēlu, lai to palielinātu).</span><span class="sxs-lookup"><span data-stu-id="21bb8-159">When sending this to the engine, it is split out into eight jobs, as shown in the following illustration (select the image to enlarge it).</span></span>

<span data-ttu-id="21bb8-160">[![Plānošanas programmas darbi](media/scheduling-engine-jobs.png "Plānošanas programmas darbi")](media/scheduling-engine-jobs-large.png)</span><span class="sxs-lookup"><span data-stu-id="21bb8-160">[![Scheduling engine jobs](media/scheduling-engine-jobs.png "Scheduling engine jobs")](media/scheduling-engine-jobs-large.png)</span></span>

<span data-ttu-id="21bb8-161">Standarta saite starp diviem darbiem ir `FinishStart`, kas nozīmē, ka viena darba beigu laikam jābūt pirms cita darba sākuma laika.</span><span class="sxs-lookup"><span data-stu-id="21bb8-161">The standard link between two jobs is `FinishStart`, meaning that the end time of one job must be before the start time of another job.</span></span> <span data-ttu-id="21bb8-162">Tā kā iestatījumus ir jāpilda tam pašam resursam, kas vēlāk veiks procesu, starp tiem pastāv `OnSameResource` ierobežojumi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-162">Because the setup must be performed by the same resource that will later do the process, there are `OnSameResource` constraints between them.</span></span> <span data-ttu-id="21bb8-163">Starp darbiem primārajai un sekundārajai operācijai 10 pastāv `StartStart` un `FinishFinish` saites, kas nozīmē, ka abiem darbiem ir jāsākas un jābeidzas vienlaicīgi, un pastāv `NotOnSameResource` ierobežojumi, kas nepieļaus vienu resursu primārajam un sekundārajam darbam.</span><span class="sxs-lookup"><span data-stu-id="21bb8-163">Between the jobs for primary and secondary operation for 10, there are `StartStart` and `FinishFinish` links, which means that the jobs must both start and end at the same time, and there are `NotOnSameResource` constraints, which will prevent the same resource for primary and secondary.</span></span>

<span data-ttu-id="21bb8-164">Operācijai 20, kur resursu daudzums ir iestatīts kā 3, procesa darbs ir sadalīts trīs atšķirīgos darbos, kur visiem darbiem ir jātiek izpildītiem vienā un tajā pašā laikā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-164">For operation 20, where the quantity of resources has been set to 3, the process job has been split into three distinct jobs where all the jobs must run at the exact same time.</span></span>
<span data-ttu-id="21bb8-165">Šajā gadījumā maršruta grupa ir iestatīta tā, lai nerezervētu gaidīšanas laiku pēc, tāpēc rindai pēc tam ir tikai viens darbs.</span><span class="sxs-lookup"><span data-stu-id="21bb8-165">In this case, the route group has been set up to not reserve capacity for queue after times, which is why there is only a single job for the queue after.</span></span>

<span data-ttu-id="21bb8-166">Plānošanas programma izprot tikai darbu jēdzienus un tai nav informācijas par operācijām.</span><span class="sxs-lookup"><span data-stu-id="21bb8-166">The scheduling engine only understands the concepts of jobs and has no notion of operations.</span></span> <span data-ttu-id="21bb8-167">Tas nozīmē, ka, veicot operāciju plānošanu, arī operācijas tiek sadalītas darbos, kaut gan tie netiks saglabātas datu bāzē.</span><span class="sxs-lookup"><span data-stu-id="21bb8-167">This means that when doing operation scheduling, the operations are also split into jobs, although these will not be persisted in the database.</span></span>

<span data-ttu-id="21bb8-168">Katram darbam mēs noteiksim arī, kādas ir darba noslodzes prasības (nepieciešamo sekunžu skaits).</span><span class="sxs-lookup"><span data-stu-id="21bb8-168">For each job, we will also define what the job capacity requirement is (the number of seconds required).</span></span> <span data-ttu-id="21bb8-169">Atkarībā no tā, kā definētas resursu prasības, mēs varam arī katram darbam nosūtīt sarakstu ar visiem potenciālajiem izmantojamajiem resursiem, kas būtu nepieciešami darba palaišanai, un to, kādas noslodzes prasības ir konkrētajam resursam.</span><span class="sxs-lookup"><span data-stu-id="21bb8-169">Depending on how the resource requirements have been defined, we may also, for each job, send a list of all the potential applicable resources that the job could run on and what the capacity requirement is for that specific resource.</span></span> <span data-ttu-id="21bb8-170">Kaut gan izmantojamo resursu saraksts tiek nosūtīts, veidojot modeli, programmai tik un tā ir jānodrošina, ka resursu piešķire ir faktiski atbilstoša visam darba ilgumam.</span><span class="sxs-lookup"><span data-stu-id="21bb8-170">Even though the list of applicable resources is sent when building the model, the engine will still need to ensure that the resource assignment is actually valid for the entire job duration.</span></span>

## <a name="scheduling-engine-internals"></a><span data-ttu-id="21bb8-171">Plānošanas programmas iekšējie parametri</span><span class="sxs-lookup"><span data-stu-id="21bb8-171">Scheduling engine internals</span></span>

### <a name="scheduling-engine-interface"></a><span data-ttu-id="21bb8-172">Plānošanas programmas interfeiss</span><span class="sxs-lookup"><span data-stu-id="21bb8-172">Scheduling engine interface</span></span>

<span data-ttu-id="21bb8-173">Lai gūtu priekšstatu par to, kā programma darbojas iekšēji, vislabāk ir apskatīt funkcionalitāti, ko tā parāda ārēji.</span><span class="sxs-lookup"><span data-stu-id="21bb8-173">To get an idea of how the engine works internally, it is best to look at the functionality it exposes externally.</span></span> <span data-ttu-id="21bb8-174">X++ galvenais interfeiss ir `WrkCtrSchedulerEngineInterface`.</span><span class="sxs-lookup"><span data-stu-id="21bb8-174">In X++, the main interface is `WrkCtrSchedulerEngineInterface`.</span></span> <span data-ttu-id="21bb8-175">Tam ir metodes, kas aprakstītas tālākajās apakšsadaļās.</span><span class="sxs-lookup"><span data-stu-id="21bb8-175">It has the methods described in the following subsections.</span></span>

#### <a name="general-engine"></a><span data-ttu-id="21bb8-176">Vispārēja programma</span><span class="sxs-lookup"><span data-stu-id="21bb8-176">General engine</span></span>

| <span data-ttu-id="21bb8-177">**Metode**</span><span class="sxs-lookup"><span data-stu-id="21bb8-177">**Method**</span></span> | <span data-ttu-id="21bb8-178">**Nolūks**</span><span class="sxs-lookup"><span data-stu-id="21bb8-178">**Purpose**</span></span> |
| --- | --- |
| `run` | <span data-ttu-id="21bb8-179">Ieplāno visus ielādētos darbus un atgriež kļūdas kodu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-179">Schedules all loaded jobs and returns the error code.</span></span> |
| `getJobSchedulingSequenceResult` | <span data-ttu-id="21bb8-180">Iegūst plānošanas rezultātu un pirmo kļūdas darbu secībai, ko identificējis noteikts darbs.</span><span class="sxs-lookup"><span data-stu-id="21bb8-180">Gets the scheduling result and the first error job for the sequence identified by a specific job.</span></span> |
| `validateJobCapacityReservations` | <span data-ttu-id="21bb8-181">Pārbauda noslodzes rezervācijas visiem darbiem, ko programma saglabājusi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-181">Validates the capacity reservations for all the jobs stored by the engine.</span></span> |
| `setReservationsTimeStamp` | <span data-ttu-id="21bb8-182">Nosūta laikspiedolu programmai, kuras kešatmiņā iestatītas visas jaunās noslodzes rezervācijas ieplānotajiem darbiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-182">Sends a timestamp to the engine set on all new capacity reservations for the scheduled jobs in the cache of the engine.</span></span> |
| `addPropertyToGroupAggregation` | <span data-ttu-id="21bb8-183">Pievieno rekvizītu prefiksu rekvizītu kopai, kas tiek izmantota, kad noslodze tiek apkopota.</span><span class="sxs-lookup"><span data-stu-id="21bb8-183">Adds a property prefix to the set of properties used when capacity is aggregated.</span></span> |
| `addResource` | <span data-ttu-id="21bb8-184">Pievieno resursu plānošanas programmas resursu kopai.</span><span class="sxs-lookup"><span data-stu-id="21bb8-184">Adds a resource to the scheduling engine resource pool.</span></span> |
| `addResourceGroup` | <span data-ttu-id="21bb8-185">Pievieno resursu grupu plānošanas programmas resursu grupas kopai.</span><span class="sxs-lookup"><span data-stu-id="21bb8-185">Adds a resource group to the scheduling engine resource group pool.</span></span> |
| `addResourceGroupMembership` | <span data-ttu-id="21bb8-186">Pievieno resursu kā resursu grupas elementu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-186">Adds a resource as a member to a resource group.</span></span> |
| `addOptimizationGoal` | <span data-ttu-id="21bb8-187">Pievieno plānošanas optimizācijas mērķi (ilgumu vai prioritāti).</span><span class="sxs-lookup"><span data-stu-id="21bb8-187">Adds a scheduling optimization goal (duration or priority).</span></span> |

#### <a name="individual-jobs"></a><span data-ttu-id="21bb8-188">Atsevišķi darbi</span><span class="sxs-lookup"><span data-stu-id="21bb8-188">Individual jobs</span></span>

| <span data-ttu-id="21bb8-189">**Metode**</span><span class="sxs-lookup"><span data-stu-id="21bb8-189">**Method**</span></span> | <span data-ttu-id="21bb8-190">**Nolūks**</span><span class="sxs-lookup"><span data-stu-id="21bb8-190">**Purpose**</span></span> |
| --- | --- |
| `addJobInfo` | <span data-ttu-id="21bb8-191">Pievieno darba informācijas ierakstu, kas informē programmu par darbu, kas jāieplāno.</span><span class="sxs-lookup"><span data-stu-id="21bb8-191">Adds a job information record that informs the engine about a job that should be scheduled.</span></span> |
| `addConstraintJobEndsAt` | <span data-ttu-id="21bb8-192">Pievieno ierobežojumu, ka darbs būtu jāpabeidz norādītajā datumā un laikā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-192">Adds a constraint that a job should end at a specified date and time.</span></span> |
| `addConstraintJobStartsAt` | <span data-ttu-id="21bb8-193">Pievieno ierobežojumu, ka darbs būtu jāsāk norādītajā datumā un laikā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-193">Adds a constraint that a job should start at a specified date and time.</span></span> |
| `addConstraintMaxJobDays` | <span data-ttu-id="21bb8-194">Definē ierobežojumu, ka darba process var tikt izdalīts norādīta maksimālā dienu skaita ietvaros.</span><span class="sxs-lookup"><span data-stu-id="21bb8-194">Defines the constraint that a job can span over a specified maximal number of days.</span></span> |
| `addConstraintResourceRequirement` | <span data-ttu-id="21bb8-195">Pievieno ierobežojumu, ka darba izpildē ir jāieplāno noteikta resursa izmantošana.</span><span class="sxs-lookup"><span data-stu-id="21bb8-195">Adds the constraint that the job must be scheduled on a specific resource.</span></span> |
| `addJobBindPriority` | <span data-ttu-id="21bb8-196">Pievieno ar darbu saistītu prioritāti (darba, ierobežojuma līmeņa) pārim.</span><span class="sxs-lookup"><span data-stu-id="21bb8-196">Adds a job bind priority for a (job, constraint level) pair.</span></span> <span data-ttu-id="21bb8-197">Augstākas prioritātes vērtība nozīmē, ka darba mainīgie tiks saistīti agrāk.</span><span class="sxs-lookup"><span data-stu-id="21bb8-197">A higher priority value means the job variables will be bound earlier.</span></span> <span data-ttu-id="21bb8-198">Darbs tiks apstrādāts pirms darbiem ar zemāku prioritātes vērtību tajā pašā secībā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-198">The job will be processed before jobs with lower priority value in the same sequence.</span></span> |
| `addJobCapacity` | <span data-ttu-id="21bb8-199">Pievieno darba noslodzes informāciju (piemēram, darbam nepieciešamo izpildlaiku) neatkarīgi no tā, kāds resurss tiek izmantos darba izpildē.</span><span class="sxs-lookup"><span data-stu-id="21bb8-199">Adds capacity load information for a job (like the required job runtime) independent on which resource the job runs on.</span></span> |
| `addJobResourceCapacity` | <span data-ttu-id="21bb8-200">Pievieno resursu resursu kopai, ko var izmantot, lai veiktu darbu, un nosaka noslodzi, kas nepieciešama, lai veiktu darbu, izmantojot šo resursu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-200">Adds a resource to the set of resources that may be used to perform a job, and states the capacity required when running on that resource.</span></span> |
| `addJobGoal` | <span data-ttu-id="21bb8-201">Pievieno darba mērķa informāciju noteiktam ierobežojuma līmenim (agrākais beigu laiks vai vēlākais sākuma laiks).</span><span class="sxs-lookup"><span data-stu-id="21bb8-201">Adds job goal information for a specific constraint level (earliest end time or latest start time).</span></span> |
| `addJobResourcePriority` | <span data-ttu-id="21bb8-202">Pievieno prioritāti, ko izmantot, kad ieplānota darba veikšana, izmantojot konkrētu resursu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-202">Adds the priority to use when a job is scheduled on a resource.</span></span> |
| `addJobResourceRuntime` | <span data-ttu-id="21bb8-203">Norāda darba laiku, kas ir atkarīgs no resursa, uz kuru pamatojoties tiks ieplānots darbs.</span><span class="sxs-lookup"><span data-stu-id="21bb8-203">Specifies a job time that is dependent of the resource the job will be scheduled on.</span></span> |
| `addJobRuntime` | <span data-ttu-id="21bb8-204">Norāda darba laiku, kas nav atkarīgs no resursa, uz kura pamata tiks ieplānots darbs.</span><span class="sxs-lookup"><span data-stu-id="21bb8-204">Specifies a job time that is independent of the resource on which the job will be scheduled.</span></span> |
| `scheduleJobOnResourceGroup` | <span data-ttu-id="21bb8-205">Atzīmē darbu plānošanai resursu grupas līmenī.</span><span class="sxs-lookup"><span data-stu-id="21bb8-205">Marks a job for scheduling on the resource group level.</span></span> |
| `setJobResourcePreemptionAllowed` | <span data-ttu-id="21bb8-206">Iestata, vai darbam uz resursa pamata ir atļautas pirmtiesības (ja programmai ir atļauts ieplānot darbu attālos noslodzes slotos).</span><span class="sxs-lookup"><span data-stu-id="21bb8-206">Sets whether preemption is allowed for a job on a resource (if engine is allowed to schedule the job in noncontiguous capacity slots).</span></span> |
| `setRequiredNumberOfResources` | <span data-ttu-id="21bb8-207">Iestata resursu skaitu, kas nepieciešami, lai ieplānotu darbu (tikai operāciju plānošanai).</span><span class="sxs-lookup"><span data-stu-id="21bb8-207">Sets the number of resources required to schedule a job (only for operations scheduling).</span></span> |

#### <a name="constraints-between-jobs"></a><span data-ttu-id="21bb8-208">Ierobežojumi starp darbiem</span><span class="sxs-lookup"><span data-stu-id="21bb8-208">Constraints between jobs</span></span>

| <span data-ttu-id="21bb8-209">**Metode**</span><span class="sxs-lookup"><span data-stu-id="21bb8-209">**Method**</span></span> | <span data-ttu-id="21bb8-210">**Nolūks**</span><span class="sxs-lookup"><span data-stu-id="21bb8-210">**Purpose**</span></span> |
| --- | --- |
| `addJobLink` | <span data-ttu-id="21bb8-211">Pievieno saiti (piemēram, beigas\>sākums) starp diviem darbiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-211">Adds a link (such as finish\>start) between two jobs.</span></span> |
| `addConstraintEndsDelayed` | <span data-ttu-id="21bb8-212">Definē ierobežojumu, ka darbu nevar beigt pirms citu darbu beigšanas, ieskaitot zināmu aizkavēšanās laiku.</span><span class="sxs-lookup"><span data-stu-id="21bb8-212">Defines the constraint that a job cannot end before another jobs end plus some delay time.</span></span> |
| `addConstraintJobListWorkingTimeIntersect` | <span data-ttu-id="21bb8-213">Pievieno ierobežojumu, ka darbiem paredzētajiem noslodzes slotiem jābūt pārklātos darba laikos tiem diviem resursiem, kas izmantoti šajos darbos.</span><span class="sxs-lookup"><span data-stu-id="21bb8-213">Adds a constraint that the capacity slots reserved for the jobs must be on the intersecting working times for the two resources used by the jobs.</span></span> |
| `addConstraintJobOverlap` | <span data-ttu-id="21bb8-214">Pievieno ierobežojumu, kas nosaka, kā darbi tiek kārtoti, kad norādīts krājuma daudzums var tikt pārvietots starp diviem resursiem, kamēr pirmā resursa apstrāde vēl nav beigusies, lai varētu sākt otrā resursa apstrādi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-214">Add a constraint that defines how jobs are sequenced when a given quantity of an item can be moved between two resources while the first resource is still not finished processing, so that the second resource can start processing.</span></span> |
| `addConstraintNotOnSameResource` | <span data-ttu-id="21bb8-215">Pievieno ierobežojumu, ka divus darbus nedrīkst ieplānot uz viena un tā paša resursa pamata.</span><span class="sxs-lookup"><span data-stu-id="21bb8-215">Adds a constraint that two jobs should not be scheduled on the same resource.</span></span> |
| `addConstraintOnSameResource` | <span data-ttu-id="21bb8-216">Pievieno ierobežojumu, ka diviem darbiem jāizmanto viens un tas pats resurss.</span><span class="sxs-lookup"><span data-stu-id="21bb8-216">Adds a constraint that two jobs must be using the same resource.</span></span> |
| `addJobSameReservations` | <span data-ttu-id="21bb8-217">Pievieno ierobežojumu, ka darbam rezultātā jābūt ar noslodzes rezervācijām tajos pašos laika slotos kā primārajam darbam.</span><span class="sxs-lookup"><span data-stu-id="21bb8-217">Adds a constraint that a job must end up having capacity reservations for the same time slots as the primary job.</span></span> |
| `setPrimaryParallelJob` | <span data-ttu-id="21bb8-218">Pievieno informāciju par to, kurš darbs ir primārais darbs paralēlu darbu kopā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-218">Adds information about what job is the primary job in a set of parallel jobs.</span></span> |

### <a name="solver"></a><span data-ttu-id="21bb8-219">Risinātājs</span><span class="sxs-lookup"><span data-stu-id="21bb8-219">Solver</span></span>

<span data-ttu-id="21bb8-220">Pati programma būtībā ir specializēts ierobežojumu risinātājs ar pievienotu pielāgotu heiristiku.</span><span class="sxs-lookup"><span data-stu-id="21bb8-220">The engine itself is essentially a specialized constraint solver with custom heuristics added.</span></span> <span data-ttu-id="21bb8-221">Risinātāja pamatā ir divi galvenie elementi: mainīgie un ierobežojumi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-221">The solver is based on two main elements: variables and constraints.</span></span>

#### <a name="variable"></a><span data-ttu-id="21bb8-222">Mainīgā</span><span class="sxs-lookup"><span data-stu-id="21bb8-222">Variable</span></span>

<span data-ttu-id="21bb8-223">Mainīgais attēlo iespējamo vērtību domēnu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-223">A variable represents a domain of possible values.</span></span> <span data-ttu-id="21bb8-224">Plānošanas programmai ir divi mainīgo tipi:</span><span class="sxs-lookup"><span data-stu-id="21bb8-224">Scheduling engine has two types of variables:</span></span>

- <span data-ttu-id="21bb8-225">**DateTime mainīgais** — tam ir domēns visiem datumiem un laikiem, un domēnu var ierobežot, pārvietojot apakšējo un augšējo mainīgā laika robežu tuvāk vienu otrai.</span><span class="sxs-lookup"><span data-stu-id="21bb8-225">**DateTime variable** - Has a domain of all dates and times, and the domain can be restricted by moving the lower and upper bound for the time of the variable closer to each other.</span></span>
- <span data-ttu-id="21bb8-226">**Resursu mainīgais** — tam ir piemērojamo resursu domēns, un domēnu var ierobežot, izslēdzot resursus no saraksta.</span><span class="sxs-lookup"><span data-stu-id="21bb8-226">**Resource variable** - Has a domain of applicable resources, and the domain can be restricted by eliminating resources from the list.</span></span>

#### <a name="constraint"></a><span data-ttu-id="21bb8-227">Ierobežojums</span><span class="sxs-lookup"><span data-stu-id="21bb8-227">Constraint</span></span>

<span data-ttu-id="21bb8-228">Ierobežojums attiecas uz mainīgajiem, ierobežojot to domēnus, bet tas ir atkarīgs arī no mainīgajiem, tāpēc tas tiek aktivizēts, kad mainās mainīgie.</span><span class="sxs-lookup"><span data-stu-id="21bb8-228">A constraint acts on variables by restricting their domains, but it also depends on variables so it gets activated when variables change.</span></span> <span data-ttu-id="21bb8-229">„Ierobežojuma izplatīšanas” process ir, kad ierobežojums veic savu galveno funkciju un sniedz atskaites galvenajai loģikai, ja tas ir veiksmīgs.</span><span class="sxs-lookup"><span data-stu-id="21bb8-229">The process of "constraint propagation" is when a constraint performs its main function and reports back to the main logic if successful.</span></span>

<span data-ttu-id="21bb8-230">Mainīgais ir uzskatāms par saistītu, kad to nevar vairāk ierobežot, kas DateTime mainīgajam nozīmē, ka augšējā un apakšējā robeža ir vienāda un resursa mainīgajam, ka tam ir tikai viens piemērojams resurss.</span><span class="sxs-lookup"><span data-stu-id="21bb8-230">A variable is considered bound when it can't be restricted further, which for DateTime variable means that upper and lower bound is the same, and for the Resource variable that it has only a single applicable resource.</span></span> <span data-ttu-id="21bb8-231">Kad visi mainīgie ir saistīti, tiek atrasts risinājums.</span><span class="sxs-lookup"><span data-stu-id="21bb8-231">When all variables are bound, a solution is found.</span></span>

### <a name="constraint-levels"></a><span data-ttu-id="21bb8-232">Ierobežojumu līmeņi</span><span class="sxs-lookup"><span data-stu-id="21bb8-232">Constraint levels</span></span>

<span data-ttu-id="21bb8-233">Kad plānošana tiek izpildīta kā daļa no materiālu vajadzību plānošanas (MRP) segšanas posma, pasūtījumi tiks plānoti atpakaļejošā secībā no pieprasījuma datuma.</span><span class="sxs-lookup"><span data-stu-id="21bb8-233">When scheduling is executed as part of the material requirements planning (MRP) coverage phase, the orders will be scheduled backward from requirement date.</span></span> <span data-ttu-id="21bb8-234">Tomēr, ja nav iespējams atrast grafiku, kas sākas šodien vai vēlāk, un beidzas pirms pieprasījuma datuma, tad plānošanas virziens mainīsies uz priekšu no šodienas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-234">However, if it is not possible to find a schedule that starts today or later and ends before the requirement date, then the scheduling direction will change to forward from today.</span></span>

<span data-ttu-id="21bb8-235">Šī galvenā biznesa kārtula tiek apstrādāta, grupējot ierobežojumus līmeņos.</span><span class="sxs-lookup"><span data-stu-id="21bb8-235">This main business rule is handled by organizing the constraints in levels.</span></span> <span data-ttu-id="21bb8-236">Ja, izmantojot augstākā līmeņa ierobežojumus, netiek atrasts risinājums, tad visi šī līmeņa ierobežojumi tiek atmesti, un tiek izmēģināts zemāks līmenis.</span><span class="sxs-lookup"><span data-stu-id="21bb8-236">If no solution is found when using the constraints on the highest level, then the constraints on that level are all dropped, and the lower level is tried.</span></span> <span data-ttu-id="21bb8-237">Praksē tas nozīmē, ka atpakaļejošas plānošanas gadījumā modelī būs 1. līmenis ar darba mērķiem, ar vēlāko sākuma laiku, kam piešķirts maksimālais beigu laika ierobežojums (pieprasījuma datums), un 0. līmenis ar darba mērķiem ar agrāko, kam piešķirts minimālais sākuma laika ierobežojums no šodienas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-237">In praxis, this means that for backward scheduling the model will contain a level 1 with job goals of latest start time given a maximum end time constraint (the requirement date), and a level 0 with job goals of earliest end time and given a minimum start time constraint of today.</span></span>

### <a name="algorithm"></a><span data-ttu-id="21bb8-238">Algoritms</span><span class="sxs-lookup"><span data-stu-id="21bb8-238">Algorithm</span></span>

<span data-ttu-id="21bb8-239">Galvenie programmas algoritma soļi ir šādi:</span><span class="sxs-lookup"><span data-stu-id="21bb8-239">The main steps of the engine algorithm are:</span></span>

1. <span data-ttu-id="21bb8-240">Atrast sērijas (darbu ķēdes), ko var atrisināt atsevišķi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-240">Find sequences (job chains) which can be solved separately.</span></span>
1. <span data-ttu-id="21bb8-241">Mēģināt atrast sākotnējo sērijas risinājumu augstākajam ierobežojuma līmenim.</span><span class="sxs-lookup"><span data-stu-id="21bb8-241">Try to find an initial solution for the sequence for the highest constraint level.</span></span>
    1. <span data-ttu-id="21bb8-242">Kārtot darbus secībā, pamatojoties uz darba mērķi un prioritātēm, lai varētu atrast sākšanas darbu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-242">Sort the jobs in the sequence based on job goal and priorities, such that a start job can be found.</span></span>
    1. <span data-ttu-id="21bb8-243">Atkārtot darbus šādā secībā:</span><span class="sxs-lookup"><span data-stu-id="21bb8-243">Loop the jobs in the following sequence:</span></span>
        1. <span data-ttu-id="21bb8-244">Atrast visus ierobežojumus, kas ir jāizplata un jāpalaiž izplatīšana.</span><span class="sxs-lookup"><span data-stu-id="21bb8-244">Find all constraints that need to be propagated and run propagation.</span></span>
        1. <span data-ttu-id="21bb8-245">Ja ir saistīti visi darba mainīgie, tad šim darbam ir atrasts risinājums.</span><span class="sxs-lookup"><span data-stu-id="21bb8-245">If all variables for the job have been bound, then a solution for that job has been found.</span></span>
        1. <span data-ttu-id="21bb8-246">Ja kādu no mainīgajiem nevar saistīt, nepārkāpjot ierobežojumus, atritiniet mainīgo saistījumu, izmēģiniet citu vērtību domēnā (resursa mainīgajam) un atkārtoti palaidiet ierobežojumu izplatīšanu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-246">If one of the variables could not be bound without violating the constraints, then roll back the variable binding, try a different value in the domain (for resource variable), and rerun the constraint propagation.</span></span>
1. <span data-ttu-id="21bb8-247">Ja risinājums netika atrasts, tiks noņemti visi pašreizējā ierobežojuma līmeņa ierobežojumi, pazemināts ierobežojuma līmenis (ja ir pieejami zemāki līmeņi) un risinājuma meklēšana tiks veikta atkārtoti ar jauno ierobežojuma kopu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-247">If no solution was found, then all constraints on the current constraint level is removed, the constraint level lowered (if any lower levels are available) and solution search retried with the new set of constraint.</span></span>
1. <span data-ttu-id="21bb8-248">Ja ir atrasts izpildāms risinājums, tiek sākta optimizācijas fāze, kas mēģinās atrast labāku risinājumu, līdz tiks sasniegts optimizācijas taimauts vai visas resursu kombinācijas būs izsmeltas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-248">If a feasible solution was found, then the optimization phase is started, which will try to find a better solution until the optimization timeout is reached or all resource combinations have been exhausted.</span></span>

<span data-ttu-id="21bb8-249">Ierobežojumu risinātājs neapzinās plānošanas algoritma specifiku.</span><span class="sxs-lookup"><span data-stu-id="21bb8-249">The constraint solver is not aware of the specifics of the scheduling algorithm.</span></span> <span data-ttu-id="21bb8-250">„Maģija” norisinās dažādo ierobežojumu definīcijās un kombinācijās.</span><span class="sxs-lookup"><span data-stu-id="21bb8-250">It is in the definition and combination of the various constraints that the "magic" happens.</span></span>

### <a name="determining-working-times"></a><span data-ttu-id="21bb8-251">Darba laiku noteikšana</span><span class="sxs-lookup"><span data-stu-id="21bb8-251">Determining working times</span></span>

<span data-ttu-id="21bb8-252">Liela daļa no (iekšējiem) ierobežojumiem programmā kontrolē resursa darba laiku un noslodzi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-252">A large part of the (internal) constraints in the engine controls the working time and capacity of a resource.</span></span> <span data-ttu-id="21bb8-253">Būtībā uzdevums ir šķērsot resursa darba laika slotus no noteikta punkta noteiktā virzienā, un atrast pietiekami ilgu intervālu, kurā var ietilpt darbam nepieciešamā noslodze (laiks).</span><span class="sxs-lookup"><span data-stu-id="21bb8-253">Essentially, the task is to traverse the working time slots for a resource from a given point in a given direction, and find a long enough interval in which the jobs required capacity (time) can fit.</span></span>

<span data-ttu-id="21bb8-254">Lai to paveiktu, programmai ir jāzina resursa darba laiki.</span><span class="sxs-lookup"><span data-stu-id="21bb8-254">To do this, the engine needs to know the working times of a resource.</span></span> <span data-ttu-id="21bb8-255">Pretēji galvenā modeļa datiem, darba laiki tiek *atlikti ielādēti*, kas nozīmē, ka tie tiek ielādēti programmā pēc nepieciešamības.</span><span class="sxs-lookup"><span data-stu-id="21bb8-255">Opposite to the main model data, the working times are *lazy loaded*, meaning that they are loaded into the engine as needed.</span></span> <span data-ttu-id="21bb8-256">Pamatojums šai pieejai ir tāds, ka bieži vien Supply Chain Management kalendārā darba laiki atrodas ļoti ilga laika perioda ietvaros, un parasti pastāv daudz kalendāru, tāpēc datu apjoms būtu samērā liels iepriekšējas ielādes veikšanai.</span><span class="sxs-lookup"><span data-stu-id="21bb8-256">The reason for this approach is that there are often working times in Supply Chain Management for a calendar for a very long period and typically many calendars exist so the data would be quite large to pre-load.</span></span>

<span data-ttu-id="21bb8-257">Programma pieprasa kalendāra informāciju pa daļām, izsaucot X++ klases metodi `WrkCtrSchedulingInteropDataProvider.getWorkingTimes`.</span><span class="sxs-lookup"><span data-stu-id="21bb8-257">Calendar information is requested by the engine in chunks, by invoking the X++ class method `WrkCtrSchedulingInteropDataProvider.getWorkingTimes`.</span></span> <span data-ttu-id="21bb8-258">Pieprasījums ir paredzēts noteiktam kalendāra ID noteiktā laika intervālā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-258">The request is for a specific calendar ID in a specific time interval.</span></span> <span data-ttu-id="21bb8-259">Atkarībā no servera kešatmiņas stāvokļa Supply Chain Management, katrs no šiem pieprasījumiem varētu rezultēties ar vairākiem datu bāzes izsaukumiem, kas aizņem ilgu laiku (salīdzinot ar tīro skaitļošanas laiku).</span><span class="sxs-lookup"><span data-stu-id="21bb8-259">Depending on the state of the server cache in Supply Chain Management, each of these requests could end up in several database calls, which takes a long time (relative to the pure computational time).</span></span> <span data-ttu-id="21bb8-260">Turklāt, ja kalendārā ir iekļautas ļoti detalizētas darba laika definīcijas ar vairākiem darba laika intervāliem dienā, tas palielina ielādes laiku.</span><span class="sxs-lookup"><span data-stu-id="21bb8-260">Also, if the calendar contains very elaborate working time definitions with many working time intervals per day, this adds to the time the loading takes.</span></span>

<span data-ttu-id="21bb8-261">Kad darba laika dati ir ielādēti plānošanas programmā, tas tiek saglabāts tās iekšējā kešatmiņā noteiktajam kalendāram, kas nozīmē, ka, ja kādi citi darbi vai resursi izmanto to pašu kalendāru, tad nākamās uzmeklēšanas no atmiņas varēs veikt ātri.</span><span class="sxs-lookup"><span data-stu-id="21bb8-261">When the working time data is loaded in the scheduling engine, this is retained in its internal cache for the specific calendar, meaning that if any other jobs or resources are using the same calendar then the next lookups can be performed quickly from memory.</span></span> <span data-ttu-id="21bb8-262">Viens kopīgs sliktas veiktspējas cēlonis ir, ja katram resursam tiek izmantots atsevišķs kalendāra ID, jo pēc tam dati ir jāpieprasa katram kalendāram, kaut gan kalendāru saturs var būt vienāds.</span><span class="sxs-lookup"><span data-stu-id="21bb8-262">One common cause of bad performance is if a separate calendar ID is used for each resource, because data will then need to be requested for each calendar, even though the content of the calendars might be the same.</span></span>

### <a name="finite-capacity"></a><span data-ttu-id="21bb8-263">Ierobežota noslodze</span><span class="sxs-lookup"><span data-stu-id="21bb8-263">Finite capacity</span></span>

<span data-ttu-id="21bb8-264">Izmantojot ierobežoto noslodzi, darba laika sloti kalendārā tiek sadalīti un samazināti, pamatojoties uz esošajām noslodzes rezervācijām.</span><span class="sxs-lookup"><span data-stu-id="21bb8-264">When using finite capacity, the working time slots from the calendar are split and reduced based on the existing capacity reservations.</span></span> <span data-ttu-id="21bb8-265">Šīs rezervācijas tiek paņemtas arī, izmantojot to pašu `WrkCtrSchedulingInteropDataProvider` klasi, ko izmanto kalendāri, bet izmantojiet metodi `getCapacityReservations`.</span><span class="sxs-lookup"><span data-stu-id="21bb8-265">These reservations are also fetched through the same `WrkCtrSchedulingInteropDataProvider` class as the calendars, but instead use the method `getCapacityReservations`.</span></span> <span data-ttu-id="21bb8-266">Plānojot vispārējās plānošanas laikā, rezervācijas noteiktam vispārējam plānam tiek ņemtas vērā un, ja tās ir iespējotas lapā **Vispārējās plānošanas parametri**, tiek iekļautas arī rezervācijas no apstiprinātajiem ražošanas pasūtījumiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-266">When scheduling during master planning, the reservations for the specific master plan are considered and if enabled on the **Master planning parameters** page, the reservations from firmed production orders are also included.</span></span> <span data-ttu-id="21bb8-267">Līdzīgi, plānojot ražošanas pasūtījumu, pastāv arī opcija iekļaut rezervācijas no esošajiem plānotajiem pasūtījumiem, lai gan šī pieeja nav tik izplatīta kā rīkošanās otrādi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-267">Similarly, when scheduling a production order, it is also an option to include reservations from existing planned orders, although this is not as common as the other way around.</span></span>

<span data-ttu-id="21bb8-268">Ierobežotas noslodzes izmantošana izraisīs plānošanas paildzināšanos vairāku iemeslu dēļ:</span><span class="sxs-lookup"><span data-stu-id="21bb8-268">Using finite capacity will cause scheduling to take longer due to several reasons:</span></span>

- <span data-ttu-id="21bb8-269">Noslodzes informācijas paņemšana no datu bāzes ir lēna operācija, un noslodzes informācijas servera puses kešdarbe parasti nav tik laba kā darba laikos, jo tie netiek koplietoti starp resursiem kā, piemēram, parasti tiek koplietoti kalendāri.</span><span class="sxs-lookup"><span data-stu-id="21bb8-269">Fetching the capacity information from database is a slow operation and the server-side caching of capacity information is typically not as good as for working times because they are not shared among resources like calendars typically are.</span></span>
- <span data-ttu-id="21bb8-270">Darba laika slotu skaits, kas jāšķērso, palielinās sadalījumu dēļ, un parasti slotiem jātiek pārbaudītiem ilgāku laika posmu, līdz tiek atrasts risinājums.</span><span class="sxs-lookup"><span data-stu-id="21bb8-270">The number of working time slots to traverse increases due to the splits, and slots for a longer time period must typically be investigated before a solution can be found.</span></span>
- <span data-ttu-id="21bb8-271">Pēc tam, kad plānošana ir pabeigta, ir jāveic konfliktējošo rezervāciju pārbaude (detalizētu informāciju skatiet sadaļā „Plānošanas programmu vienlaicīga palaišana”).</span><span class="sxs-lookup"><span data-stu-id="21bb8-271">After the scheduling is complete, a check for conflicting reservations must be performed (see the "Running scheduling engines in parallel" section for details).</span></span>

### <a name="examining-the-resource-combinations"></a><span data-ttu-id="21bb8-272">Resursu kombināciju izpēte</span><span class="sxs-lookup"><span data-stu-id="21bb8-272">Examining the resource combinations</span></span>

<span data-ttu-id="21bb8-273">Ja darba secība ietver tikai standarta `FinishStart` saites, tas ir, tā veido vienkāršu ķēdi bez zariem, optimālais rezultāts (redzams no viena pasūtījuma, nevis viscaur pasūtījumiem) var tikt sasniegts, atrodot labāko risinājumu pirmajam darbam un pēc tam meklējot labāko risinājumu nākamajam darbam.</span><span class="sxs-lookup"><span data-stu-id="21bb8-273">If the job sequence only contains the standard `FinishStart` links, meaning it forms a simple chain without any branches, an optimal result (seen from the single order, not across orders) can be achieved by finding the best solution for the first job and then moving on to find the best solution for the next job.</span></span> <span data-ttu-id="21bb8-274">Labākais risinājums darbam nozīmē, ka tiek atrasts resurss, kas var iegūt darba mērķim tuvākā darba sākuma un beigu datumu (turpmākajā plānošanā tas nozīmē iegūt darba beigu datumu pēc iespējas ātrāk), joprojām ievērojot ierobežojumus.</span><span class="sxs-lookup"><span data-stu-id="21bb8-274">The best solution for a job means finding the resource that can get the from and to date of the job closest to the job goal (in forward scheduling this means getting the end date of the job as early as possible) while still respecting the constraints.</span></span>

<span data-ttu-id="21bb8-275">Ja pastāv paralēli darbi, risinājuma atrašana var ietvert dažādu resursu kombināciju izpēti.</span><span class="sxs-lookup"><span data-stu-id="21bb8-275">When there are parallel jobs, finding a solution may involve examining different combinations of resources.</span></span> <span data-ttu-id="21bb8-276">Iespējamo resursu kombināciju skaits ir piemērojamu resursu skaita reizinājums, ko iespējams izmantot saistītajiem paralēlajiem darbiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-276">The number of possible resource combinations is the product of the number of applicable resources for the connected parallel jobs.</span></span> <span data-ttu-id="21bb8-277">Jo īpaši, plānojot pasūtījumu atpakaļejošā veidā no pieprasījuma datuma, tas var aizņemt diezgan ilgu laiku, lai loģika saprastu, ka nepastāv problēmas risinājums, kas ietilpinās paralēlus darbus pirms šodienas datuma, tā kā tai būs jāpārbauda visas kombinācijas, jo varētu būt daži resursi, kam ir augstāka efektivitāte vai cits kalendārs, kas varētu dot rezultātu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-277">Especially when scheduling an order backwards from a requirement date, it can take quite a while for the logic to realize that there is no solution to the problem that will make the parallel jobs fit before today's date, as it will need to check all the combinations because there could be some resources that had a higher efficiency or a different calendar that might give a result.</span></span> <span data-ttu-id="21bb8-278">Tas nozīmē, ka, ja nav iestatīts taimauta ierobežojums, tā darbosies ilgu laiku pirms virziena maiņas uz priekšu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-278">This means that if no timeout limit has been set it will run for a long time before changing the direction to forward.</span></span>

<span data-ttu-id="21bb8-279">Šī kombinētā loģika nozīmē arī to, ka, papildu piemērotu resursu pievienošana var izraisīt programmas palēnināšanos.</span><span class="sxs-lookup"><span data-stu-id="21bb8-279">This combinatorial logic also means that adding more applicable resources may make the engine run slower.</span></span> <span data-ttu-id="21bb8-280">Ja veiktspējas problēmas rodas, veicot paralēlas operācijas un plānojot ar neierobežotu noslodzi, to daļēji var labot, liekot maršruta projektētāju pieņemt lēmumu par to, kurš resurss jāizmanto, un pēc tam tieši piešķirt resursu operācijai (jo vairumā gadījumu programma vienmēr norādīs vienu un to pašu resursu, tāpēc gala rezultāts būs tāds pats).</span><span class="sxs-lookup"><span data-stu-id="21bb8-280">If performance problems occur when having parallel operations and scheduling with infinite capacity, it can partly be fixed by having the route designer take a decision on which resource should be used and then assign the resource directly on the operation (because the engine in most cases will always end up picking the same resource, so the end result will be the same).</span></span>

### <a name="hard-links"></a><span data-ttu-id="21bb8-281">Fiksētās saites</span><span class="sxs-lookup"><span data-stu-id="21bb8-281">Hard links</span></span>

<span data-ttu-id="21bb8-282">Fiksēta saites veida iestatīšana starp diviem darbiem nodrošina, ka nav laika intervālu starp viena darba beigām un nākamā darba sākumu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-282">Setting the link type between two jobs to hard, ensures that there is no time gap between the finish of one job and the start of the next one.</span></span> <span data-ttu-id="21bb8-283">Tas var būt ļoti noderīgi situācijās, kā, piemēram, kad metāls tiek karsēts viena darba ietvaros un pēc tam apstrādāts nākamajā darbā, kad nav vēlama metāla atdzišana starpposmā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-283">This can be very useful in scenarios like when metal is heated in one job and then processed in the next job, where it is not desirable to have the metal cool down in between.</span></span>

<span data-ttu-id="21bb8-284">Ar standarta nefiksētajām saitēm un plānošanu uz priekšu, ja maršruts veido vienkāršu ķēdi bez zariem, rezultātu var sasniegt, atrodot risinājumu pirmajam darbam, kas ievēro tā ierobežojumus, un tad virzīties cauri ķēdei, izplatot beigu laiku no iepriekšējā darba uz nākamo darbu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-284">With standard soft links and forward scheduling, if the route forms a simple chain without any branches, a result can be achieved by finding a solution for the first job that satisfies its own constraints and then moving on through the chain propagating the end time from the previous job to the next job.</span></span> <span data-ttu-id="21bb8-285">Ja pašreizējais darbs nevar atrast nevienu noslodzi, tā sākuma laiks tiks pārvietots tālāk, neietekmējot iepriekšējos darbus, kas potenciāli radītu atstarpes starp darbiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-285">If the current job can't find any capacity, the start time for it will be moved out further, without any consequence for the previous jobs potentially creating gaps between the jobs.</span></span> <span data-ttu-id="21bb8-286">Tomēr ar fiksētajām saitēm (jo īpaši saistībā ar ierobežoto noslodzi) tādā pašā situācijā fakts, ka viens darbs tālāk ķēdē nevar atrast noslodzi, nozīmēs, ka visi iepriekšējie ieplānotie darbi būs „jāvelk” pa vienam, un tādējādi jāpārplāno vairākas reizes.</span><span class="sxs-lookup"><span data-stu-id="21bb8-286">However with hard links (especially in connection with finite capacity) for the same scenario, the fact that one job later in the chain cannot find capacity, will mean that all previous scheduled jobs will have to be "dragged" along one by one and thereby rescheduled a number of times.</span></span> <span data-ttu-id="21bb8-287">Jo īpaši tādās situācijās, kurās ir liela vairāku resursu noslodze, fiksētās saites var izraisīt ķēdes reakciju, kur darbi ietekmēs cits citu un tie būs jāatkārto vairākas reizes, pirms rezultāts tiks stabilizēts iespējama grafika formā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-287">Especially in scenarios with high load for multiple resources, the hard links can cause a chain reaction where the jobs will affect each other and a number of iterations will have to be performed before the result stabilizes into a feasible schedule.</span></span>

## <a name="running-scheduling-engines-in-parallel"></a><span data-ttu-id="21bb8-288">Plānošanas programmu vienlaicīga palaišana</span><span class="sxs-lookup"><span data-stu-id="21bb8-288">Running scheduling engines in parallel</span></span>

<span data-ttu-id="21bb8-289">Veicot plānošanu kā daļu no vispārējās plānošanas izpildes, kur tiek izmantoti palīgi, katrs no vispārējā plānošanas palīga pavedieniem var saņemt arī ražošanas pasūtījuma plānošanas uzdevumus.</span><span class="sxs-lookup"><span data-stu-id="21bb8-289">When performing scheduling as part of a master planning run where helpers are used, each of the master planning helper threads can also pick up production order scheduling tasks.</span></span> <span data-ttu-id="21bb8-290">Tas nozīmē, ka vienlaicīgi var darboties vairākas plānošanas programmas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-290">This means that multiple scheduling engines can be running at the same time.</span></span> <span data-ttu-id="21bb8-291">Kaut gan vairākpavedienu struktūra kopumā ir ļoti nozīmīga veiktspējas priekšrocība, attiecībā uz plānošanu pastāv arī daži funkcionālie trūkumi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-291">While multithreading in general is a highly significant performance benefit, there are also some functional downsides when it comes to scheduling.</span></span>

<span data-ttu-id="21bb8-292">MRP visi norādītā materiālu komplekta (MK) līmeņa ražošanas pasūtījumi tiek plānoti pieprasījuma datumu secībā, tas nozīmē, ka pasūtījumi ar agrāko pieprasījuma datumu ir jāieplāno vispirms un tādējādi tiem ir vislielākā iespēja saņemt pieejamo resursu noslodzi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-292">In MRP, all production orders for a given bill of materials (BOM) level are scheduled in requirement date sequence, meaning that those orders with the earliest requirement date should be scheduled first and thereby have the highest chance of getting the available resource capacity.</span></span> <span data-ttu-id="21bb8-293">Tomēr, vairākām programmām veicot izvēli no neieplānoto pasūtījumu saraksta, secība vairs netiek nodrošināta, jo viens var tikt paveikts ātrāk nekā cits.</span><span class="sxs-lookup"><span data-stu-id="21bb8-293">However, with multiple engines picking from the list of unscheduled orders the sequence is no longer ensured, as one might complete faster than the other.</span></span>

<span data-ttu-id="21bb8-294">Turklāt, plānojot ierobežotas noslodzes lietošanu, kad vairākas programmas instances mēģina ieplānot pasūtījumus, kas potenciāli izmanto vienus un tos pašus resursus tajā pašā laika intervālā, var rasties sacensības nosacījums.</span><span class="sxs-lookup"><span data-stu-id="21bb8-294">Also, when scheduling using finite capacity and when multiple engine instances are trying to schedule orders that are potentially using the same resources at the same time interval, a race condition can occur.</span></span> <span data-ttu-id="21bb8-295">Šādu sacensības nosacījumu skaits tiek saglabāts laukā **Plānošanas konflikti** vispārējā plānu vēstures lapā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-295">The number of such race conditions is recorded in the **Scheduling conflicts** field on the master plans history page.</span></span> <span data-ttu-id="21bb8-296">Konfliktu risināšanas loģika ir šāda:</span><span class="sxs-lookup"><span data-stu-id="21bb8-296">The conflict resolution logic is as follows:</span></span>

- <span data-ttu-id="21bb8-297">Ieplānojiet pasūtījumu (bez bloķēšanas) un iegūstiet noslodzes rezervācijas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-297">Schedule an order (lock-free) and get capacity reservations.</span></span>
- <span data-ttu-id="21bb8-298">Paņemiet slēdzeni.</span><span class="sxs-lookup"><span data-stu-id="21bb8-298">Take the lock.</span></span>
- <span data-ttu-id="21bb8-299">Pārbaudiet, vai ieplānotajiem resursiem laika intervālā pastāv jaunākas noslodzes rezervācijas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-299">Check if newer capacity reservations exist for the scheduled resources in the timespan.</span></span>
  - <span data-ttu-id="21bb8-300">Ja nē, ierakstiet noslodzi un noņemiet bloķēšanu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-300">If no, write the capacity and release the lock.</span></span>
  - <span data-ttu-id="21bb8-301">Ja atbilde ir Jā, noņemiet bloķēšanu un pārplānojiet pasūtījumu no sākuma.</span><span class="sxs-lookup"><span data-stu-id="21bb8-301">If yes, release the lock and reschedule the order from the beginning.</span></span>

<span data-ttu-id="21bb8-302">Tātad, plānojot ar vairākiem programmas instancēm, rezultāts nav pilnībā noteikts, jo tas būs atkarīgs no katra pavediena precīzā laika.</span><span class="sxs-lookup"><span data-stu-id="21bb8-302">So, when scheduling with multiple engine instances, the result is not fully deterministic because it will depend on the exact timing of each of the threads.</span></span>

## <a name="operation-scheduling-performance"></a><span data-ttu-id="21bb8-303">Operāciju plānošanas veiktspēja</span><span class="sxs-lookup"><span data-stu-id="21bb8-303">Operation scheduling performance</span></span>

<span data-ttu-id="21bb8-304">Lai gan operāciju plānošana ir zināma arī kā rupja griezuma noslodzes plānošana, kas redzams no programmas skatpunkta, tā var būt grūtāk risināma problēma, ja tiek izmantota ierobežota noslodze, jo ir nepieciešams vairāk datu, lai noteiktu iespējamību.</span><span class="sxs-lookup"><span data-stu-id="21bb8-304">Even though operation scheduling is also known as rough-cut capacity planning, seen from an engine standpoint, it can be a harder problem to solve if finite capacity is used, as more data is needed to determine feasibility.</span></span>

<span data-ttu-id="21bb8-305">Resursu grupas noslodze ir atkarīga no tā, kuri un cik daudzi resursi ir resursu grupas dalībnieki.</span><span class="sxs-lookup"><span data-stu-id="21bb8-305">The capacity of a resource group depends on which and how many resources are members of the resource group.</span></span> <span data-ttu-id="21bb8-306">Resursu grupai pašai par sevi nav noslodzes&mdash;, tikai, ja resursi ir grupas dalībnieki, tai būs noslodze.</span><span class="sxs-lookup"><span data-stu-id="21bb8-306">A resource group in itself does not have any capacity&mdash;only when resources are a member of the group will it have capacity.</span></span> <span data-ttu-id="21bb8-307">Tā kā dalība resursu grupā var laika gaitā mainīties, noslodze ir jānovērtē ik dienu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-307">Because the resource group membership can vary over time, capacity must be evaluated per day.</span></span>

<span data-ttu-id="21bb8-308">Operāciju plānošanā resursu grupas kalendārs tiek izmantots, lai noteiktu katras operācijas sākuma un beigu laikus.</span><span class="sxs-lookup"><span data-stu-id="21bb8-308">In operations scheduling, the resource group's calendar is used to determine the start and end times for each operation.</span></span> <span data-ttu-id="21bb8-309">Tas nozīmē, ka resursu grupas kalendārs nosaka limitu, cik laika var ieplānot vienai operācijai vienā dienā vienā resursu grupā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-309">This means that the resource group's calendar places a limit on how much time can be operations scheduled for one operation on one day in one resource group.</span></span> <span data-ttu-id="21bb8-310">Pretēji noteikta resursa kalendāram, resursu grupas efektivitātes dati kalendārā tiek ignorēti, jo tie vienkārši apzīmē darba laiku un nevis faktisko noslodzi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-310">Opposite the calendar for the specific resources, the efficiency data of the calendar is ignored for the resource group as it simply denotes opening hours and not actual capacity.</span></span>

<span data-ttu-id="21bb8-311">Piemēram, ja darba laiks resursu grupai kādā noteiktā datumā ir no 8:00 līdz 16:00, viena operācija nevar likt lielāku slodzi uz resursu grupu, kā to, ko var ietilpināt 8 stundu intervālā, neatkarīgi no tā, cik liela noslodze resursu grupai kopā ir pieejama šajā dienā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-311">For example, if the working time for a resource group on one specific date is from 8:00 to 16:00, one operation can't put more load on the resource group than what can be fit into 8 hours, no matter how much capacity that the resource group has available in total on that day.</span></span> <span data-ttu-id="21bb8-312">Tomēr pieejamā noslodze var vairāk ierobežot noslodzi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-312">The available capacity can however limit the load further.</span></span>

<span data-ttu-id="21bb8-313">Noslodze no darba plānošanas uz visiem resursiem, kas iekļauti resursu grupā attiecīgajā dienā, tiek ņemta vērā, kad tiek aprēķināta pieejamā resursu grupas noslodze tajā pašā dienā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-313">The load from job scheduling on all the resources included in the resource group on a given day is considered when the available capacity for the resource group on the same day is calculated.</span></span> <span data-ttu-id="21bb8-314">Katram datumam aprēķins ir šāds:</span><span class="sxs-lookup"><span data-stu-id="21bb8-314">For each date, the calculation is:</span></span>

<span data-ttu-id="21bb8-315">*Pieejamo resursu grupas noslodze = resursu noslodze grupā, pamatojoties uz to kalendāru &ndash; Darba ieplānoto noslodzi resursiem grupā &ndash; Operāciju ieplānoto noslodzi resursiem grupā &ndash; Operāciju ieplānoto noslodzi resursiem grupā*</span><span class="sxs-lookup"><span data-stu-id="21bb8-315">*Available resource group capacity = Capacity for resources in the group based on their calendar &ndash; Job scheduled load on the resources in the group &ndash; Operations scheduled load on the resources in the group &ndash; Operations scheduled load on the resource group*</span></span>

<span data-ttu-id="21bb8-316">Cilnē **Resursu vajadzības**, kas atrodas maršruta operācijā, resursu vajadzības var norādīt, izmantojot noteiktu resursu (tādā gadījumā operācija tiks ieplānota, izmantojot šo resursu), resursu grupai, resursu veidam vai vienai vai vairākām iespējām, prasmei, kursam vai sertifikātam.</span><span class="sxs-lookup"><span data-stu-id="21bb8-316">On the **Resource requirements** tab on the route operation, the resource requirements can be specified using either a specific resource (in which case the operation will be scheduled using that resource), for a resource group, for a resource type, or for one or more capabilities, skill, course, or certificate.</span></span> <span data-ttu-id="21bb8-317">Lai gan visu šo opciju izmantošana sniedz lielu elastību maršruta dizainā, tas arī sarežģī programmas plānošanu, jo noslodze jāuzskaita katram „Rekvizītam” (abstrakts nosaukums, kas tiek izmantots programmā, lai aprakstītu iespējas, prasmes utt.).</span><span class="sxs-lookup"><span data-stu-id="21bb8-317">While using all of these options gives a great flexibility on the route design, it also complicates the scheduling for the engine as the capacity must be accounted for per "property" (the abstract name used in the engine for capability, skills, and so on).</span></span>

<span data-ttu-id="21bb8-318">Resursu grupas noslodze iespējai ir noslodzes summa visiem resursu grupas resursiem, kam ir attiecīgā noslodze.</span><span class="sxs-lookup"><span data-stu-id="21bb8-318">The resource group's capacity for a capability is the sum of the capacity for all resources in the resource group that has the capability in question.</span></span> <span data-ttu-id="21bb8-319">Ja resursam grupā ir iespēja, tad tā tiks ņemta vērā neatkarīgi no tā, kāds ir nepieciešamās noslodzes līmenis.</span><span class="sxs-lookup"><span data-stu-id="21bb8-319">If a resource in the group has a capability, it will be considered no matter what level of the capacity is required.</span></span>

<span data-ttu-id="21bb8-320">Operāciju plānošanā pieejamā noslodze noteiktai resursu grupas iespējai tiks samazināta, kad tā tiks ielādēta ar operāciju, kas pieprasa attiecīgo iespēju.</span><span class="sxs-lookup"><span data-stu-id="21bb8-320">In operations scheduling, the available capacity for a certain capability for a resource group will be reduced when it is loaded with an operation that requires the capability in question.</span></span> <span data-ttu-id="21bb8-321">Ja operācijai ir nepieciešama vairāk nekā viena iespēja, noslodze tiks samazināta visām nepieciešamajām iespējām.</span><span class="sxs-lookup"><span data-stu-id="21bb8-321">If the operation requires more than one capability, the capacity will be reduced for all required capabilities.</span></span>

<span data-ttu-id="21bb8-322">Katram datumam nepieciešamais aprēķins ir šāds:</span><span class="sxs-lookup"><span data-stu-id="21bb8-322">For each date, the required calculation is:</span></span>

<span data-ttu-id="21bb8-323">*Pieejamā iespējas noslodze = iespējas noslodze &ndash; Darba ieplānotā noslodze resursiem ar specifiskām iespējām, kas iekļautas resursu grupā &ndash; Operāciju ieplānotā noslodze resursiem ar specifiskām iespējām, kas iekļautas resursu grupā &ndash; Operāciju ieplānotā noslodze pašā resursu grupā, kurai nepieciešama konkrētā iespēja*</span><span class="sxs-lookup"><span data-stu-id="21bb8-323">*Available capacity for a capability = Capacity for the capability &ndash; Job scheduled load on the resources with the specific capability, included in the resource group &ndash; Operations scheduled load on the resources with the specific capability, included in the resource group &ndash; Operations scheduled load on the resource group itself that require the specific capability*</span></span>

<span data-ttu-id="21bb8-324">Tas nozīmē, ka, ja ir noslodze uz noteiktu resursu, noslodze tiek ņemta vērā, aprēķinot resursu grupai pieejamo noslodzi vienai iespējai, jo noslodze uz noteiktu resursu samazina tā ieguldījumu resursu grupas noslodzē, lai varētu izmantot iespēju, neatkarīgi no tā, vai noslodze uz konkrēto resursu paredzēta konkrētajai iespējai.</span><span class="sxs-lookup"><span data-stu-id="21bb8-324">This means that if there is load on a specific resource, the load is considered in the calculation of the resource group's available capacity per capability, because the load on a specific resource reduces its contribution to the resource group's capacity for a capability no matter if the load on the specific resource is for that specific capability.</span></span> <span data-ttu-id="21bb8-325">Ja ir noslodze resursu grupas līmenī, tas tiek ņemts vērā, aprēķinot resursu grupas pieejamo noslodzi vienai iespējai tikai tad, ja noslodze ir no operācijas, kurai nepieciešama noteiktā iespēja.</span><span class="sxs-lookup"><span data-stu-id="21bb8-325">If there is load on the resource group level, it is considered in the calculation of the resource group's available capacity per capability only if the load is from an operation that requires the specific capability.</span></span>

<span data-ttu-id="21bb8-326">Iepriekšminētā loģika ir komplicēta, jo tā ir vienāda katram „rekvizīta” veidam, tāpēc, lai izmantotu operāciju plānošanu ar ierobežotu noslodzi, nepieciešams ielādēt ievērojamu datu apjomu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-326">The above logic is complicated, as this is the same for each type of "property" so using operations scheduling with finite capacity requires a significant amount of data to be loaded.</span></span>

## <a name="viewing-scheduling-engine-input-and-output"></a><span data-ttu-id="21bb8-327">Plānošanas programmas ievades un izvades skatīšana</span><span class="sxs-lookup"><span data-stu-id="21bb8-327">Viewing scheduling engine input and output</span></span>

<span data-ttu-id="21bb8-328">Lai iegūtu noteiktu, detalizētu informāciju par plānošanas procesa ievadi un izvadi, iespējojiet reģistrēšanu, dodoties uz **Organizācijas administrēšana \> Iestatījumi \> Plānošana \> Plānošanas izsekošanas kontrolpults**.</span><span class="sxs-lookup"><span data-stu-id="21bb8-328">To get specific details of the input and output of the scheduling process,  enable logging by going to **Organization administration \> Setup \> Scheduling \> Scheduling tracing cockpit**.</span></span>

<span data-ttu-id="21bb8-329">Šajā lapā vispirms atlasiet **Iespējot reģistrēšanu** darbību rūtī.</span><span class="sxs-lookup"><span data-stu-id="21bb8-329">On this page, first select **Enable logging** on the Action Pane.</span></span> <span data-ttu-id="21bb8-330">Tad palaidiet ražošanas pasūtījuma plānošanu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-330">Then run the scheduling for the production order.</span></span> <span data-ttu-id="21bb8-331">Kad tā pabeigta, atgriezieties lapā **Plānošanas izsekošanas kontrolpults** un darbības rūtī atlasiet **Atspējot reģistrēšanu**.</span><span class="sxs-lookup"><span data-stu-id="21bb8-331">When complete, return to the **Scheduling tracing cockpit** page and select **Disable logging** on the Action Pane.</span></span> <span data-ttu-id="21bb8-332">Atsvaidziniet lapu, un režģī tiks parādīta jauna rinda.</span><span class="sxs-lookup"><span data-stu-id="21bb8-332">Refresh the page and a new line will appear in the grid.</span></span> <span data-ttu-id="21bb8-333">Atlasiet jauno rindu un darbības rūtī atlasiet **Lejupielādēt**.</span><span class="sxs-lookup"><span data-stu-id="21bb8-333">Select the new line and select **Download** on the Action Pane.</span></span> <span data-ttu-id="21bb8-334">Šī darbība sniegs jums. zip formātā saspiestu mapi, kurā ietverti šādi faili:</span><span class="sxs-lookup"><span data-stu-id="21bb8-334">This will give you a .zip compressed folder containing the following files:</span></span>

- <span data-ttu-id="21bb8-335">**Log.txt** — šis ir žurnāla fails, kas apraksta darbības, kuras secīgi veic programma.</span><span class="sxs-lookup"><span data-stu-id="21bb8-335">**Log.txt** - This is the log file that describes the steps that the engine goes through.</span></span> <span data-ttu-id="21bb8-336">Tas ir ļoti komplicēts, un var būt mazliet apgrūtinošs, bet, ja tas tiek izmantots kā daļa no eksperimentēšanas ar maršruta iestatīšanu, lai atrisinātu veiktspējas problēmas, pirmā lieta, ko meklēt, ir laika atšķirība starp pirmo un pēdējo rindu, jo tas dos jums precīzu laiku, kuru patērējis plānotājs.</span><span class="sxs-lookup"><span data-stu-id="21bb8-336">It is very elaborate and can be a bit overwhelming, but when used as part of experimenting with the route setup to resolve performance problems the first thing to look for is the difference in time between the first and the last line, as this will give you the exact time the scheduler has spent.</span></span>
- <span data-ttu-id="21bb8-337">**XmlModel.xml** — tas satur modeli, kas ir būvēts X++ un uz kura pamata darbojas programma.</span><span class="sxs-lookup"><span data-stu-id="21bb8-337">**XmlModel.xml** - This contains the model that is built in X++ and that the engine operates on.</span></span> <span data-ttu-id="21bb8-338">Failā izmantotais `JobId` korelē ar `RecId` no avota tabulas, kas satur darbus (`ReqRouteJob` vai `ProdRouteJob`).</span><span class="sxs-lookup"><span data-stu-id="21bb8-338">The `JobId` used in the file correlates to the `RecId` from the source table containing the jobs (`ReqRouteJob` or `ProdRouteJob`).</span></span> <span data-ttu-id="21bb8-339">Tipiskā lieta, ko meklēt šajā failā, ir tas, ka datumi, kas doti `ConstraintJobStartsAt` un `ConstraintJobEndsAt` atbilst paredzētajam, ka `JobGoal` rekvizīts ir iestatīts pareizi un ka darbi ir saistīti viens ar otru, izmantojot `JobLink` ierobežojumus.</span><span class="sxs-lookup"><span data-stu-id="21bb8-339">The typical thing to look for in this file is that the dates given in `ConstraintJobStartsAt` and `ConstraintJobEndsAt` are as expected, that the `JobGoal` property is set correctly, and that the jobs are related to each other through the `JobLink` constraints.</span></span>
- <span data-ttu-id="21bb8-340">**XmlSlots.xml** — tas ietver visus darba laikus un noslodzes rezervācijas, ko programma ir pieprasījusi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-340">**XmlSlots.xml** - This contains all the working times and capacity reservations that the engine has requested.</span></span> <span data-ttu-id="21bb8-341">Kalendāra darba laiki un rezervācijas programma pieprasīs tikai tiem laika posmiem, kuros tā mēģina izvietot darbus (un papildu buferi), tāpēc, ja fails ietver laikus ļoti tālu nākotnē, tas var norādīt uz problēmu ar iestatījumiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-341">The calendar working times and reservations will only be requested by the engine for the time periods where it tries to place the jobs (and an extra buffer), so if the file contains times very far in the future, it might be an indication of a problem with the setup.</span></span> <span data-ttu-id="21bb8-342">`ResourceProperty` mezgli katram resursam parādīs, ar kuru resursu grupu un iespējām tas ir saistīts un kuros periodos.</span><span class="sxs-lookup"><span data-stu-id="21bb8-342">The `ResourceProperty` nodes will show for each resource which resource group and capabilities it is associated with for which periods.</span></span>
- <span data-ttu-id="21bb8-343">**Result.xml** — tas ietver plānošanas izpildes rezultātus.</span><span class="sxs-lookup"><span data-stu-id="21bb8-343">**Result.xml** - This contains the result of the scheduling run.</span></span>

<span data-ttu-id="21bb8-344">Ņemiet vērā, ka izsekošanas funkcionalitāte var pievienot būtisku veiktspējas pārtēriņu, tāpēc izmantojiet to tikai, lai izpētītu noteiktu pasūtījumu plānošanu kontrolētā veidā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-344">Note that the tracing functionality can add significant performance overhead, so only use it for investigating scheduling of specific orders in a controlled manner.</span></span> <span data-ttu-id="21bb8-345">Ja vispārējās plānošanas izpildes laikā tas ir ieslēgts, tas ātri sasniegs savu lieluma ierobežojumu un apstāsies.</span><span class="sxs-lookup"><span data-stu-id="21bb8-345">If it is turned on during a master planning run it will quickly reach its size limit and stop.</span></span>

## <a name="troubleshooting-performance"></a><span data-ttu-id="21bb8-346">Problēmu novēršanas veiktspēja</span><span class="sxs-lookup"><span data-stu-id="21bb8-346">Troubleshooting performance</span></span>

<span data-ttu-id="21bb8-347">Kā tas ir saprotams no visām iepriekšējām sadaļām, plānošanas programmas iestatīšanai un izmantošanai piemīt dažas nepilnības, kas var izraisīt veiktspējas problēmas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-347">As can be understood from all of the previous sections, there are some pitfalls when it comes to the setup and usage of the scheduling engine, which can lead to performance problems.</span></span> <span data-ttu-id="21bb8-348">Problēmu novēršanai varat izmantot šādu kontrolsarakstu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-348">The following check list can be used for troubleshooting such issues.</span></span> <span data-ttu-id="21bb8-349">Ir svarīgi apskatīt visus punktus, jo problēmas visbiežāk iztaisa vairāku faktoru kombinācija.</span><span class="sxs-lookup"><span data-stu-id="21bb8-349">It is important to look at all the points as it is most often a combination of multiple factors that leads to problems.</span></span>

### <a name="performing-scheduling-as-part-of-mrp-when-it-is-not-needed"></a><span data-ttu-id="21bb8-350">Tiek veikta plānošana kā daļa no MRP, ja tā nav nepieciešams</span><span class="sxs-lookup"><span data-stu-id="21bb8-350">Performing scheduling as part of MRP when it is not needed</span></span>

<span data-ttu-id="21bb8-351">Kaut arī maršruti tiek izmantoti ražošanas kontroles nolūkiem, piemēram, izmaksu aprēķināšanai un pārskatiem, iespējams, MRP laikā nav nepieciešams tos ņemt vērā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-351">Even though routes are used for the production control purposes such as costing and reporting, it might not be necessary to consider them during MRP.</span></span> <span data-ttu-id="21bb8-352">Dažos gadījumos, standarta ražošanas izpildes laika norādīšana krājumam būs pietiekama plānošanai.</span><span class="sxs-lookup"><span data-stu-id="21bb8-352">In some cases, having a standard production lead time specified for the item will be sufficient for planning.</span></span> <span data-ttu-id="21bb8-353">Lai izslēgtu maršruta plānošanu, iestatiet noslodzes periodu uz nulli.</span><span class="sxs-lookup"><span data-stu-id="21bb8-353">To turn off route scheduling, set the capacity time fence to zero.</span></span> <span data-ttu-id="21bb8-354">Ja plānošana ir jāveic, noslodzes laika periods ir rūpīgi jāiestata, jo, iespējams, nav nepieciešams ņemt vērā maršrutus pilna MRP vajadzības perioda robežās.</span><span class="sxs-lookup"><span data-stu-id="21bb8-354">If scheduling should be done, then the capacity time fence must be carefully set because it might not be necessary to consider routes for the full extent of the MRP's coverage time fence.</span></span>

<span data-ttu-id="21bb8-355">Ņemiet vērā, ka, ja pasūtījums nav ieplānots MRP laikā, tā vietā tas ir jāplāno, kad plānotais pasūtījums ir apstiprināts.</span><span class="sxs-lookup"><span data-stu-id="21bb8-355">Note that if the order is not scheduled during MRP, then it will instead need to be scheduled when the planned order is firmed.</span></span> <span data-ttu-id="21bb8-356">Tas nozīmē, ka apstiprināšanas process būs ilgāks, tāpēc atkarībā no tā, cik no ieteiktajiem plānotajiem pasūtījumiem tiek apstiprināti, veiktspējas pieaugums MRP laikā var tikt zaudēts pie apstiprināšanas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-356">This means that the firming process will take longer, so depending on how many of the suggested planned orders get firmed the performance gain during MRP might be lost at firming.</span></span>

### <a name="route-with-unnecessary-operations"></a><span data-ttu-id="21bb8-357">Maršruts ar nevajadzīgām operācijām</span><span class="sxs-lookup"><span data-stu-id="21bb8-357">Route with unnecessary operations</span></span>

<span data-ttu-id="21bb8-358">Veidojot maršrutu, ir vilinoši mēģināt modelēt reālo pasauli tieši — ar visām ražošanas darbībām.</span><span class="sxs-lookup"><span data-stu-id="21bb8-358">When designing the route, it is tempting to try to model the real world exactly with all the steps the production goes through.</span></span> <span data-ttu-id="21bb8-359">Lai gan dažos gadījumos tas var būt noderīgi, tas nav labi veiktspējai, jo modelis, uz kura pamata programmai ir jāstrādā, palielinās (attiecībā gan uz darbu, gan ierobežojumiem), un vairāk SQL priekšrakstu tiks izpildīti, lai ievietotu un atjauninātu darbus un noslodzes rezervācijas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-359">While this can be useful in some cases, it is not good for the performance as the model the engine needs to work on gets larger (both in terms of jobs and constraints) and more SQL statements will be executed for insertion and update of the jobs and capacity reservations.</span></span> <span data-ttu-id="21bb8-360">Ir arī pakārtotās sekas — laika gaitā par darbu norisi ir jāziņo, ko var atvieglot ar automātiskiem grāmatojumiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-360">Also, there is the downstream effect of having to eventually report progress on the jobs, which can be mitigated with automatic postings.</span></span> <span data-ttu-id="21bb8-361">Ja dati nekam netiek lietoti, tas veido nevajadzīgu noslodzi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-361">If the data is not used for anything, it creates unnecessary load.</span></span>

<span data-ttu-id="21bb8-362">Ieteicams izveidot tikai tās operācijas, kas ir absolūti nepieciešamas plānošanai (kas parasti ir deficīta resursi) un/vai izmaksu aprēķināšanas nolūkam.</span><span class="sxs-lookup"><span data-stu-id="21bb8-362">We recommend that you only create operations that are strictly needed for scheduling (which will typically be the bottleneck resources) and/or costing purposes.</span></span> <span data-ttu-id="21bb8-363">Vai arī jums jāgrupē daudzas mazākas, atšķirīgas operācijas vienā lielākā operācijā, kas pārstāv lielāko procesa daļu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-363">Alternatively you should group many smaller distinct operations into one larger operation that represents a greater part of the process.</span></span>

### <a name="many-applicable-resources-for-an-operation"></a><span data-ttu-id="21bb8-364">Daudzi operācijām piemērojami resursi</span><span class="sxs-lookup"><span data-stu-id="21bb8-364">Many applicable resources for an operation</span></span>

<span data-ttu-id="21bb8-365">Piemērojamo resursu skaitu operācijai nosaka resursu prasības, kas iestatītas operāciju relācijā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-365">The number of applicable resources for an operation is determined by the resource requirements set on the operation relation.</span></span> <span data-ttu-id="21bb8-366">Vajadzība var būt pēc specifiska (atsevišķa) resursa, vai arī tā var pamatoties uz resursa piederību resursu grupai vai iespēju.</span><span class="sxs-lookup"><span data-stu-id="21bb8-366">The requirement can either be for a specific (individual) resource or it can be based on the resource's membership of a resource group or capability.</span></span>

<span data-ttu-id="21bb8-367">Ja plānošana nav veikta, izmantojot ierobežoto noslodzi un visiem piemērojamajiem resursiem ir viens un tas pats kalendārs un efektivitāte, tad plānošanas programma operācijai vienmēr rezultātā izvēlēsies vienu un to pašu resursu, bet tikai pēc visu atbilstošo resursu izmēģināšanas, lai pārbaudītu, vai ir viens, kas ir „labāks” par citiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-367">If scheduling is not done using finite capacity and all the applicable resources have the same calendar and efficiency, then the scheduling engine will always end up picking the same resource for an operation, but only after trying all the applicable resources to check if there is one that is "better" than the others.</span></span> <span data-ttu-id="21bb8-368">Šādā gadījumā plānošanas noslodzi var ievērojami samazināt vienkārši, vienmēr piešķirot operācijai noteiktu resursu maršruta izveides laikā.</span><span class="sxs-lookup"><span data-stu-id="21bb8-368">In this case, the load of the scheduling can be greatly reduced simply by always assigning a specific resource to the operation at the route design time.</span></span>

### <a name="route-with-parallel-operations"></a><span data-ttu-id="21bb8-369">Maršruts ar vienlaicīgām operācijām</span><span class="sxs-lookup"><span data-stu-id="21bb8-369">Route with parallel operations</span></span>

<span data-ttu-id="21bb8-370">Lai gan paralēlas operācijas (primāras/sekundāras) ir spēcīgs rīks scenāriju modelēšanai, piemēram, kad iekārta un operators abi ir nepieciešami noteikta uzdevuma izpildei, tas ir arī daudzu veiktspējas problēmu avots.</span><span class="sxs-lookup"><span data-stu-id="21bb8-370">While parallel operations (primary/secondary) are a powerful tool to model scenarios like when a machine and an operator are both needed to perform a specific task, it is also the source of many performance issues.</span></span> <span data-ttu-id="21bb8-371">Ja noteikta, atsevišķa resursa prasība ir piešķirta gan primārajai, gan sekundārajai operācijai, parasti tā nav problēma.</span><span class="sxs-lookup"><span data-stu-id="21bb8-371">If a requirement for a specific individual resource is assigned to both the primary and secondary operation, it is typically not a problem.</span></span> <span data-ttu-id="21bb8-372">Bet, ja katrai operācijai ir daudz iespējamo resursu, tad plānošanai tiek ievērojami palielināta skaitļošanas sarežģītība.</span><span class="sxs-lookup"><span data-stu-id="21bb8-372">But if there are many possible resources for each of the operations, then it adds significant computational complexity to the scheduling.</span></span>

<span data-ttu-id="21bb8-373">Paralēlu operāciju izmantošanas alternatīva ir vai nu modelēt pārus kā „virtuālos” resursus (kas pēc tam pārstāvēs grupu, kas vienmēr operācijai tiks piešķirta kopā), vai vienkārši nemodelēt kādu no operācijām, ja tā nepārstāv kādu deficīta resursu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-373">An alternative to using parallel operations is either to model the pairs as "virtual" resources (which will then represent the team that always goes together for the operation) or to simply not model one of the operations if it doesn't represent a bottleneck.</span></span>

### <a name="route-with-quantity-of-resources-higher-than-1"></a><span data-ttu-id="21bb8-374">Operācijas ar resursu daudzumu, kas lielāks par 1</span><span class="sxs-lookup"><span data-stu-id="21bb8-374">Route with quantity of resources higher than 1</span></span>

<span data-ttu-id="21bb8-375">Ja iestatāt operācijai nepieciešamo resursu daudzumu, kas ir lielāks par vienu, tad tas efektīvi darbojas tāpat, kā lietojot primārās/sekundārās operācijas, jo programmai tiek nosūtīti vairāki paralēli darbi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-375">If setting the quantity of resources needed for an operation higher than one, then it results effectively the same as using primary/secondary operations because multiple parallel jobs are sent to the engine.</span></span> <span data-ttu-id="21bb8-376">Tomēr šim gadījumam nav iespējams izmantot noteiktas resursu piešķires, jo daudzumam, kas ir lielāks par vienu, nepieciešams, ka operācijai būtu piemērojami vairāki resursi.</span><span class="sxs-lookup"><span data-stu-id="21bb8-376">However, for this case there is not an option of using specific resource assignments, because a quantity higher than one requires that more than one resource is applicable for the operation.</span></span>

### <a name="excessive-use-of-finite-capacity"></a><span data-ttu-id="21bb8-377">Pārmērīga ierobežotas noslodzes izmantošana</span><span class="sxs-lookup"><span data-stu-id="21bb8-377">Excessive use of finite capacity</span></span>

<span data-ttu-id="21bb8-378">Ierobežotas noslodzes izmantošana paredz, ka programma noslodzes informāciju ielādētu no datu bāzes, un iespējama skaitļošanas pieskaitīšana, jo būs grūtāk atrast risinājumu, it īpaši vidēs, kur resursi ir rezervēti tuvu to maksimālajai noslodzei.</span><span class="sxs-lookup"><span data-stu-id="21bb8-378">Use of finite capacity requires the engine to load the capacity information from a database and can have a computational overhead because it will be harder to find a solution especially in environments where the resources are booked close to their maximum capacity.</span></span> <span data-ttu-id="21bb8-379">Tā rezultātā ir svarīgi rūpīgi izvērtēt, vai resursam patiešām ir jāizmanto ierobežota noslodze, vai arī tos var pārrezervēt.</span><span class="sxs-lookup"><span data-stu-id="21bb8-379">As a result, it is important to carefully evaluate if a resource really needs to use finite capacity or they can be overbooked.</span></span> <span data-ttu-id="21bb8-380">Tā kā, iespējams, pastāv atšķirība starp ierobežotas noslodzes resursiem mērā, cik svarīgi ir tos nepārrezervēt, mēs rekomendējam resursam izmantot deficīta opciju kombinācijā ar atsevišķu vērtību plānā „Perioda noslodze deficīta resursiem”.</span><span class="sxs-lookup"><span data-stu-id="21bb8-380">Because there might be a difference among finite capacity resources in how important they are not to overbook, we recommend using the bottleneck option on a resource in combination with a separate value on the plan in "Capacity time fence for bottleneck resources".</span></span> <span data-ttu-id="21bb8-381">Izmantojot deficīta konceptu, var nodrošināt, ka vispārējo ierobežoto noslodzes periodu iespējams samazināt.</span><span class="sxs-lookup"><span data-stu-id="21bb8-381">Using the bottleneck concept can enable that the general finite capacity time fence can be lowered.</span></span>

### <a name="setting-hard-links"></a><span data-ttu-id="21bb8-382">Fiksēto saišu iestatīšana</span><span class="sxs-lookup"><span data-stu-id="21bb8-382">Setting hard links</span></span>

<span data-ttu-id="21bb8-383">Maršruta standarta saites tips ir *nefiksēts*, kas nozīmē, ka ir atļauts laika intervāls starp vienas operācijas pabeigšanas laiku un nākamās sākumu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-383">The standard link type of the route is *soft*, which means that a time gap is allowed between the finishing time of one operation and the start of the next.</span></span> <span data-ttu-id="21bb8-384">Šī pieļaušana var izraisīt nevēlamas sekas, ka materiāli vai noslodze nav pieejama vienai no operācijām ļoti ilgu laiku, ražošana varētu būt dīkstāvē diezgan ilgu laiku, kas nozīmē iespējamu nepabeigtu darbu pieaugumu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-384">Allowing this can have the unfortunate effect that, if materials or capacity are not available for one of the operations for a very long time, the production could be idle for quite a while, meaning a possible increase of work in progress.</span></span> <span data-ttu-id="21bb8-385">Šis nenotiks ar fiksētām saitēm, jo beigām un sākumam ir precīzi jāsakrīt.</span><span class="sxs-lookup"><span data-stu-id="21bb8-385">This will not happen with hard links because the finish and start must align perfectly.</span></span> <span data-ttu-id="21bb8-386">Taču fiksētu saišu iestatīšana padara plānošanas problēmu sarežģītāku, jo darba laiks un noslodzes krustpunkti ir jāaprēķina diviem operāciju resursiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-386">But setting hard links makes the scheduling problem more difficult because working time and capacity intersections must be calculated for the two resources of the operations.</span></span> <span data-ttu-id="21bb8-387">Ja ir iesaistītas arī paralēlas operācijas, tas ievērojami palielina skaitļošanas laiku.</span><span class="sxs-lookup"><span data-stu-id="21bb8-387">If there are also parallel operations involved, this adds significant computational time.</span></span> <span data-ttu-id="21bb8-388">Ja abu operāciju resursiem ir atšķirīgi kalendāri, kas vispār nepārklājas, problēma ir neatrisināma.</span><span class="sxs-lookup"><span data-stu-id="21bb8-388">If the resources of the two operations have different calendars that don't overlap at all, the problem is unsolvable.</span></span>

<span data-ttu-id="21bb8-389">Ieteicams izmantot fiksētās saites tikai tad, kad tas ir konkrēti nepieciešams, un rūpīgi apsvērt, vai tas ir nepieciešams katrai maršruta operācijai.</span><span class="sxs-lookup"><span data-stu-id="21bb8-389">We recommend using hard links only when strictly necessary, and carefully consider if it is necessary for each operation of the route.</span></span>

<span data-ttu-id="21bb8-390">Lai samazinātu nepabeigto darbu, nelietojot fiksētās saites, risinājuma metode ir ieplānot pasūtījumu divreiz, mainot otrā soļa virzienu uz pretējo.</span><span class="sxs-lookup"><span data-stu-id="21bb8-390">To reduce the work in progress without applying hard links, a trick is to schedule the order twice with changing to the opposite direction for the second pass.</span></span> <span data-ttu-id="21bb8-391">Ja pirmais grafiks tika veikts atpakaļejošā virzienā no saņemšanas datuma, tad otrais ir jāveic no plānotā sākuma datuma uz priekšu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-391">If the first schedule was done backwards from delivery date, then the second should be done forward from the scheduled start date.</span></span> <span data-ttu-id="21bb8-392">Tā rezultātā darbi tiks saspiesti pēc iespējas vairāk, lai nepabeigtais darbs tiktu minimizēts.</span><span class="sxs-lookup"><span data-stu-id="21bb8-392">This will result in the jobs being compressed as much as possible so that the work in progress is minimized.</span></span>

### <a name="separate-calendar-for-each-resource"></a><span data-ttu-id="21bb8-393">Atsevišķs kalendārs katram resursam</span><span class="sxs-lookup"><span data-stu-id="21bb8-393">Separate calendar for each resource</span></span>

<span data-ttu-id="21bb8-394">Viens no galvenajiem plānošanas programmas datu avotiem ir kalendāra informācija, ko var būt dārgi ielādēt no datu bāzes.</span><span class="sxs-lookup"><span data-stu-id="21bb8-394">One of the main sources of data for the scheduling engine is calendar information, which can be expensive to load from the database.</span></span> <span data-ttu-id="21bb8-395">Tā kā kalendāri tiek ģenerēti, pamatojoties uz veidnēm, būtu vilinoši ģenerēt kalendāru katram resursam un pēc tam pielāgot informāciju šajā kalendārā, kad resurss atrodas dīkstāve vai ar to saistītas citas problēmas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-395">Because calendars are generated based on templates, it would be tempting to generate a calendar for each resource and then adjust the information in this calendar when the resource has downtime and other issues.</span></span> <span data-ttu-id="21bb8-396">Tomēr, veicot šo darbību, tiks ievērojami ierobežota programmas spēja ierakstīt kešatmiņā kalendāra datus, jo tai būtu jāpieprasa jauni dati katram resursam, un tas var būt liels veiktspējas problēmu avots.</span><span class="sxs-lookup"><span data-stu-id="21bb8-396">However, doing this will severely limit the engines ability to cache the calendar data as it would need to request new data for each resource and can be a large source of performance problems.</span></span> <span data-ttu-id="21bb8-397">Tā vietā ieteicams starp resursiem atkārtoti izmantot kalendārus un pēc tam kontrolēt dīkstāves izmaiņas, katram periodam piešķirot citu kalendāra ID.</span><span class="sxs-lookup"><span data-stu-id="21bb8-397">Instead, we recommend that you reuse the calendars as much as possible between the resources, and then control downtime changes by assigning a different calendar ID for a period.</span></span>

### <a name="high-number-of-working-time-slots-per-calendar-day"></a><span data-ttu-id="21bb8-398">Liels darba laika slotu skaits kalendārās dienas ietvaros</span><span class="sxs-lookup"><span data-stu-id="21bb8-398">High number of working time slots per calendar day</span></span>

<span data-ttu-id="21bb8-399">Tā kā programma darbojas, pa vienam izpētot laika slotus un to noslodzi, ir lietderīgi minimizēt laika slotu skaitu uz vienu kalendāro dienu.</span><span class="sxs-lookup"><span data-stu-id="21bb8-399">Because the engine works by examining time slots one-by-one for capacity, it is beneficial to minimize the number of time slots per calendar day.</span></span> <span data-ttu-id="21bb8-400">To var darīt, piemēram, apsverot, vai ir svarīgi iegūtajā grafikā, lai atspoguļot to, ka darbiniekiem ik stundu ir 5 minūšu pārtraukums.</span><span class="sxs-lookup"><span data-stu-id="21bb8-400">This could be done, for example, by considering whether it's important for the resulting schedule to reflect that workers have a 5-minute break every hour.</span></span>

### <a name="large-or-none-scheduling-timeouts"></a><span data-ttu-id="21bb8-401">Liels (vai neviens) plānošanas taimauts</span><span class="sxs-lookup"><span data-stu-id="21bb8-401">Large (or none) scheduling timeouts</span></span>

<span data-ttu-id="21bb8-402">Plānošanas programmas veiktspēju var optimizēt, izmantojot parametrus, kas atrodami lapā **Plānošanas parametri**.</span><span class="sxs-lookup"><span data-stu-id="21bb8-402">Scheduling engine performance can be optimized using parameters found on the **Scheduling parameters** page.</span></span> <span data-ttu-id="21bb8-403">Iestatījumiem **Iespējots plānošanas taimauts** un **Iespējots plānošanas optimizācijas taimauts** vienmēr jābūt iestatītiem uz **Jā**.</span><span class="sxs-lookup"><span data-stu-id="21bb8-403">The **Scheduling timeout enabled** and **Scheduling optimization timeout enabled** settings should always be set to **Yes**.</span></span> <span data-ttu-id="21bb8-404">Ja iestatīti uz **Nē**, plānošana potenciāli var darboties neierobežoti, ja ir izveidots neizpildāms maršruts ar daudzām opcijām.</span><span class="sxs-lookup"><span data-stu-id="21bb8-404">If set to **No**, the scheduling can potentially run infinitely if an unfeasible route with many options has been created.</span></span>

<span data-ttu-id="21bb8-405">**Maksimālais plānošanas laiks vienai secībai** vērtība kontrolē, kāds ir maksimālais sekunžu skaits, ko drīkst iztērēt, mēģinot atrast risinājumu vienai secībai (vairumā gadījumu secība atbilst vienam pasūtījumam).</span><span class="sxs-lookup"><span data-stu-id="21bb8-405">The value for **Maximum scheduling time per sequence** controls how many seconds can, at most, be spent trying to find a solution for a single sequence (in most cases a sequence corresponds to a single order).</span></span> <span data-ttu-id="21bb8-406">Šeit izmantojamā vērtība lielā mērā ir atkarīga no tā, cik sarežģīts ir maršruts un iestatījumi, piemēram, ierobežota noslodze ar maksimumu, kas nepārsniedz 30 sekundes, ir labs sākuma punkts.</span><span class="sxs-lookup"><span data-stu-id="21bb8-406">The value to use here highly depends on the complexity of the route and settings like finite capacity, ut a maximum of about 30 seconds is a good starting point.</span></span>

<span data-ttu-id="21bb8-407">**Optimizācijas mēģinājumu taimauts** kontrolē, kāds ir maksimālais sekunžu skaits, ko drīkst iztērēt, lai atrastu piemērotāku risinājumu, nekā sākotnēji atrasts.</span><span class="sxs-lookup"><span data-stu-id="21bb8-407">The value for **Optimization attempts timeout** controls how many seconds can at most be used to find a better solution than the one originally found.</span></span> <span data-ttu-id="21bb8-408">Tas ietekmēs tikai tos maršrutus, kuri lieto paralēlās operācijas, jo tie liek pārbaudīt dažādas kombinācijas.</span><span class="sxs-lookup"><span data-stu-id="21bb8-408">This will only influence routes that are using parallel operations as these make it necessary to test different combinations.</span></span>

> [!NOTE]
> <span data-ttu-id="21bb8-409">Taimautiem iestatītās vērtības tiks piemērotas gan izpildei nodoto ražošanas pasūtījumu, gan plānoto pasūtījumu plānošanai, kā daļai no MRP.</span><span class="sxs-lookup"><span data-stu-id="21bb8-409">The values set for the timeouts will be applied both for scheduling of released production orders and of planned orders as part of MRP.</span></span> <span data-ttu-id="21bb8-410">Tā rezultātā, iestatot ļoti lielas vērtības, var būtiski palielināt MRP izpildes laiku, kad tiek palaists plāns ar daudziem plānotiem ražošanas pasūtījumiem.</span><span class="sxs-lookup"><span data-stu-id="21bb8-410">As a result, setting very high values could significantly add to the run time of MRP when running for a plan with many planned production orders.</span></span>


[!INCLUDE[footer-include](../../includes/footer-banner.md)]